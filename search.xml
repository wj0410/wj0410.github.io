<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Caffeine本地缓存快速上手教程</title>
    <url>/2024/11/14/Caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>使用缓存的优点是可以减少直接访问数据库的压力。Caffeine是目前单机版缓存性能最高的，提供了最优的缓存命中率。用法和java中的map集合比较类似，底层使用一个ConcurrentHashMap来保存所有数据，可以理解为一个增强版的map集合，增强的功能有设置缓存过期时间，缓存数据驱逐，统计缓存数据等。本文会大量使用详细的代码示例，通俗易懂地帮助大家学会使用Caffeine本地缓存。</p>
<h4 id="常见QA"><a href="#常见QA" class="headerlink" title="常见QA"></a>常见QA</h4><ol>
<li>Caffeine和redis的区别？共同点都是基于内存。其中，Caffeine是本地缓存，基于单个JVM，不能直接跨多台机器分布，如果程序停止，JVM停止，本地缓存数据会全部丢失，类似java中的map集合，相比Redis，Caffeine的性能更好。Redis是一个分布式缓存系统，独立部署，支持将数据持久化到磁盘上，因此可以在应用程序关闭后仍然保留数据。Redis支持分布式架构，可以配置成主从模式或者集群模式，从而提供更好的水平扩展性和高可用性。</li>
<li>Ehcache和Caffeine的区别？Caffeine是一个较新的本地缓存框架，在内存管理和高并发访问方面通常比Ehcache更高效。</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>引入依赖即可</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>Caffeine 最核心的是com.github.benmanes.caffeine.cache.Cache接口，所有与缓存有关的处理方法，都是在这个接口之中定义的，接口中的方法见下图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411141918453.png"
                     
                ></p>
<h5 id="1-入门代码"><a href="#1-入门代码" class="headerlink" title="1. 入门代码"></a>1. 入门代码</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * .expireAfterAccess(3L, TimeUnit.SECONDS)：假设用户 &quot;Alice&quot; 第一次登录，登录状态被存储在缓存中，并且记录了最后一次访问的时间。</span></span><br><span class="line"><span class="comment">        * 假设用户 &quot;Alice&quot; 第一次登录，登录状态被存储在缓存中，并且记录了最后一次访问的时间。</span></span><br><span class="line"><span class="comment">        * 如果在3秒内没有任何请求使用了 &quot;Alice&quot; 的登录状态，那么缓存中的 &quot;Alice&quot; 条目会在3秒后自动过期，即被移除。</span></span><br><span class="line"><span class="comment">        * 下次有请求需要使用 &quot;Alice&quot; 的登录状态时，缓存会失效，需要重新加载或计算 &quot;Alice&quot; 的登录状态，并将新的状态存储在缓存中</span></span><br><span class="line"><span class="comment">        * 这样设计的好处在于，如果用户在一段时间内没有活动（例如3秒内没有操作），那么缓存中的数据会自动过期，可以确保缓存中的数据不会长时间驻留，</span></span><br><span class="line"><span class="comment">        * 从而减少缓存占用的内存空间，并且确保了数据的及时更新。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在设置了 .maximumSize(100) 之后，如果缓存中的条目数量超过了100，Caffeine 缓存库会根据一定的策略来进行缓存条目的淘汰，</span></span><br><span class="line"><span class="comment">        * 以确保缓存的大小不会无限增长。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()     <span class="comment">// 构建一个新的caffeine实例</span></span><br><span class="line">                               .maximumSize(<span class="number">100</span>)   <span class="comment">// 设置缓存之中保存的最大数据量</span></span><br><span class="line">                               .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)    <span class="comment">// 缓存数据在3秒内没被访问则失效</span></span><br><span class="line">                               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       log.info(<span class="string">&quot;未超时获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 获取数据,输出：未超时获取缓存数据，Bob= 已登录</span></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">5</span>);  <span class="comment">// 5秒后超时</span></span><br><span class="line">       log.info(<span class="string">&quot;已超时获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 获取数据，输出：已超时获取缓存数据，Bob= null</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在默认情况下，一旦缓存数据消失之后，Cache 接口可以返回的内容就是 null 数据了，于是有些人认为空数据不利于标注，</span></span><br><span class="line"><span class="comment">        * 那么此时也可以考虑进行一些数据的控制。</span></span><br><span class="line"><span class="comment">        * 这种数据加载操作指的是在缓存数据不存在的时候进行数据的同步加载处理操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       log.info(<span class="string">&quot;已超时获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;Bob&quot;</span>, (key) -&gt; &#123;  <span class="comment">// 最终输出：已超时获取缓存数据，Bob= [expire]Bob</span></span><br><span class="line">           log.info(<span class="string">&quot;失效处理，没有发现 key = &#123;&#125; 的数据，要进行失效处理控制&quot;</span>, key);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;[expire]&quot;</span> + key;  <span class="comment">// 失效数据的返回</span></span><br><span class="line">       &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-同步数据加载"><a href="#2-同步数据加载" class="headerlink" title="2. 同步数据加载"></a>2. 同步数据加载</h5><p>数据加载是指将数据放入缓存的过程<br>如果发现指定的 KEY 的缓存项不存在了，Caffeine提供相关功能，实现重新进行数据的加载，例如：通过demo01方法中的操作方法可以发现，此时当缓存数据失效之后，可以自动的根据 Function 函数式接口加载所需要的数据内容（demo01中cache.get(“Bob”, (key) -&gt; { }代码部分）<br>同步数据加载操作属于同步的操作范畴，加载不停，数据是不会返回的（所有操作均由主线程顺序执行）。而除了上文入门案例demo01中的加载机制之外，在缓存组件之中还提供有一个较为特殊的 CacheLoader 接口，这个接口的触发机制有些不太一样，它所采用的依然是同步的加载处理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span>&#123;</span><br><span class="line">       LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()     <span class="comment">// 第四步，修改变量类型为LoadingCache</span></span><br><span class="line">               .maximumSize(<span class="number">100</span>)   <span class="comment">// 设置缓存之中保存的最大数据量</span></span><br><span class="line">               .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)    <span class="comment">// 缓存数据在3秒内没被访问则失效</span></span><br><span class="line">               .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;  <span class="comment">// 第一步，build方法中传参</span></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="meta">@Nullable</span> String <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;[cacheLoader]进行缓存数据的加载处理， 当前的key = &#123;&#125;&quot;</span>, s);</span><br><span class="line">                       TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">// 第三步，模拟数据的加载延迟</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="string">&quot;【loadingcache】&quot;</span> + s;  <span class="comment">// 第二步，数据加载的返回结果</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Wang&quot;</span>, <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">&quot;未超时获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 未超时获取缓存数据，Bob= 已登录</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">5</span>);  <span class="comment">// 5秒后超时</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       cache.put(<span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;未登录&quot;</span>);  <span class="comment">// 第五步，缓存失效以后添加新的数据项</span></span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 第六步，封装一个list</span></span><br><span class="line">       list.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : cache.getAll(list).entrySet())&#123;  <span class="comment">// 第七步</span></span><br><span class="line">           log.info(<span class="string">&quot;【数据加载】key=&#123;&#125;,value=&#123;&#125;&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 第八步，返回结果</span></span><br><span class="line"><span class="comment">        * 未超时获取缓存数据，Bob= 已登录</span></span><br><span class="line"><span class="comment">        * [cacheLoader]进行缓存数据的加载处理， 当前的key = Bob</span></span><br><span class="line"><span class="comment">        * [cacheLoader]进行缓存数据的加载处理， 当前的key = Lily</span></span><br><span class="line"><span class="comment">        * 【数据加载】key=Bob,value=【loadingcache】Bob  </span></span><br><span class="line"><span class="comment">        * 【数据加载】key=Lily,value=【loadingcache】Lily  </span></span><br><span class="line"><span class="comment">        * 【数据加载】key=Lee,value=未登录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-数据的异步加载操作"><a href="#3-数据的异步加载操作" class="headerlink" title="3. 数据的异步加载操作"></a>3. 数据的异步加载操作</h5><p>多线程可以提升性能，优先，功能和上面的同步加载数据相同<br>数据加载进内存的过程是异步的，从缓存中读数据默认还是由主线程同步实现。<br>注意：缓存的value应为CompletableFuture.completedFuture(“value”)格式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">       AsyncLoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()     </span><br><span class="line">               .maximumSize(<span class="number">100</span>)   <span class="comment">// 设置缓存之中保存的最大数据量</span></span><br><span class="line">               .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)    <span class="comment">// 缓存数据在3秒内没被访问则失效</span></span><br><span class="line">               .buildAsync((key, executor) -&gt;</span><br><span class="line">                   CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;[cacheLoader]进行缓存数据的加载处理， 当前的key = &#123;&#125;&quot;</span>, key);</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">return</span> <span class="string">&quot;【loadingcache】&quot;</span> + key;</span><br><span class="line">                   &#125;)</span><br><span class="line">               );</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, CompletableFuture.completedFuture(<span class="string">&quot;已登录&quot;</span>));</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,CompletableFuture.completedFuture(<span class="string">&quot;未登录&quot;</span>));</span><br><span class="line">       cache.put(<span class="string">&quot;Wang&quot;</span>, CompletableFuture.completedFuture(<span class="string">&quot;未登录&quot;</span>));</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">&quot;未超时获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>).get());  <span class="comment">// 未超时获取缓存数据，Bob= 已登录</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">5</span>);  <span class="comment">// 5秒后超时</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       cache.put(<span class="string">&quot;Lee&quot;</span>, CompletableFuture.completedFuture(<span class="string">&quot;已登录&quot;</span>));  </span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">       list.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : cache.getAll(list).get().entrySet())&#123;  </span><br><span class="line">           log.info(<span class="string">&quot;【数据加载】key=&#123;&#125;,value=&#123;&#125;&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 结果输出</span></span><br><span class="line"><span class="comment">        * [main] INFO com.cabbage.demos.AsynJiazai - 未超时获取缓存数据，Bob= 已登录</span></span><br><span class="line"><span class="comment">        * [ForkJoinPool.commonPool-worker-2] INFO com.cabbage.demos.AsynJiazai - [cacheLoader]进行缓存数据的加载处理， 当前的key = Bob</span></span><br><span class="line"><span class="comment">        * [ForkJoinPool.commonPool-worker-11] INFO com.cabbage.demos.AsynJiazai - [cacheLoader]进行缓存数据的加载处理， 当前的key = Lily</span></span><br><span class="line"><span class="comment">        * [main] INFO com.cabbage.demos.AsynJiazai - 【数据加载】key=Bob,value=【loadingcache】Bob</span></span><br><span class="line"><span class="comment">        * [main] INFO com.cabbage.demos.AsynJiazai - 【数据加载】key=Lily,value=【loadingcache】Lily</span></span><br><span class="line"><span class="comment">        * [main] INFO com.cabbage.demos.AsynJiazai - 【数据加载】key=Lee,value=已登录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="4-缓存数据驱逐"><a href="#4-缓存数据驱逐" class="headerlink" title="4.缓存数据驱逐"></a>4.缓存数据驱逐</h5><p>默认的缓存驱逐算法是Window-TinyLFU，提供了最优命中率，有效避免热点数据的失效。<br>以下代码示例都是基于同步缓存数据加载，</p>
<h6 id="4-1-基于缓存容量的驱逐策略"><a href="#4-1-基于缓存容量的驱逐策略" class="headerlink" title="4.1 基于缓存容量的驱逐策略"></a>4.1 基于缓存容量的驱逐策略</h6><ul>
<li><p>假设缓存容量设置为1，当你设置第二条数据时，第一条数据丢失</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()     <span class="comment">// 构建一个新的caffeine实例</span></span><br><span class="line">               .maximumSize(<span class="number">1</span>)   <span class="comment">// 设置缓存之中保存的最大数据量</span></span><br><span class="line">               .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)    <span class="comment">// 缓存数据在3秒内没被访问则失效</span></span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">          有一些延迟</span></span><br><span class="line"><span class="comment">        * 如果不加sleep，会出现</span></span><br><span class="line"><span class="comment">        * 现在缓存个数已经超过了，但是最早的缓存数据还在保留，没有及时清理</span></span><br><span class="line"><span class="comment">        * 大家可以去掉sleep自己试一下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));  <span class="comment">// 输出：获取缓存数据，Bob= null</span></span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lily= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lily&quot;</span>)); <span class="comment">//输出：获取缓存数据，Lily= 未登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="4-2-基于缓存权重驱逐策略"><a href="#4-2-基于缓存权重驱逐策略" class="headerlink" title="4.2 基于缓存权重驱逐策略"></a>4.2 基于缓存权重驱逐策略</h6><ul>
<li><p>先设置一个总的权重，再为每一条数据定义权重，例如：假设总权重为100，为每条数据设置权重50，那么在你设置第三条数据的时候，会有一条缓存数据被淘汰。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span>&#123;</span><br><span class="line">   Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">           <span class="comment">// .maximumSize(100)</span></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 在进行权重驱逐策略配置的时候，使用的方法为“maximumWeiaht()&#x27;</span></span><br><span class="line"><span class="comment">            * 但是此时不要再设置保存的个数了，</span></span><br><span class="line"><span class="comment">            * 因为个数的算法和权重的算法是两个不同的方式，二选一的关系。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           .maximumWeight(<span class="number">100</span>)  <span class="comment">// 第一步，设置缓存之中的最大权重</span></span><br><span class="line">           .weigher((key, value) -&gt; &#123;  <span class="comment">// 第二步，权重计算</span></span><br><span class="line">               log.info(<span class="string">&quot;[weigher权重计算器] key = &#123;&#125;， val = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">               <span class="comment">// 实际开发之中的权重计算处理操作，可以通过KEY和VALUE的长度计算得来</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">50</span>; <span class="comment">// 第三步</span></span><br><span class="line">           &#125;)</span><br><span class="line">           .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)    <span class="comment">// 缓存数据在3秒内没被访问则失效</span></span><br><span class="line">           .build();</span><br><span class="line">   cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">   cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">   cache.put(<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">   cache.put(<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   log.info(<span class="string">&quot;获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">   log.info(<span class="string">&quot;获取缓存数据，Lily= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lily&quot;</span>));</span><br><span class="line">   log.info(<span class="string">&quot;获取缓存数据，Wang= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Wang&quot;</span>));</span><br><span class="line">   log.info(<span class="string">&quot;获取缓存数据，Lee= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 输出</span></span><br><span class="line"><span class="comment">    *  [weigher权重计算器] key = Bob， val = 已登录</span></span><br><span class="line"><span class="comment">    *  [weigher权重计算器] key = Lily， val = 未登录</span></span><br><span class="line"><span class="comment">    *  [weigher权重计算器] key = Wang， val = 未登录</span></span><br><span class="line"><span class="comment">    *  [weigher权重计算器] key = Lee， val = 已登录</span></span><br><span class="line"><span class="comment">    * 获取缓存数据，Bob= null</span></span><br><span class="line"><span class="comment">    * 获取缓存数据，Lily= null</span></span><br><span class="line"><span class="comment">    * 获取缓存数据，Wang= 未登录</span></span><br><span class="line"><span class="comment">    * 获取缓存数据，Lee= 已登录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="4-3-基于时间的驱逐策略"><a href="#4-3-基于时间的驱逐策略" class="headerlink" title="4.3 基于时间的驱逐策略"></a>4.3 基于时间的驱逐策略</h6><ul>
<li><p>在进行驱逐的时候，对于时间的管理有两种，一种是通过最后一次读的方式进行配置(见入门代码.expireAfterAccess(3L, TimeUnit.SECONDS) &#x2F;&#x2F; 缓存数据在3秒内没被访问则失效)，另外一种就是通过写的时间进行计数（写完以后的第几秒，缓存会失效）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo03</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .expireAfterWrite(<span class="number">2L</span>, TimeUnit.SECONDS)    <span class="comment">// 第一步，写入后两秒失效</span></span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">           TimeUnit.MILLISECONDS.sleep(<span class="number">1500</span>); <span class="comment">// 每次休眠1.5秒</span></span><br><span class="line">           log.info(<span class="string">&quot;[第&#123;&#125;次访问] key = &#123;&#125;, value = &#123;&#125;&quot;</span>, i, <span class="string">&quot;Bob&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 输出</span></span><br><span class="line"><span class="comment">        * 14:34:49.972 [main] INFO com.cabbage.demos.CacheEvictionManager - [第0次访问] key = Bob, value = 已登录</span></span><br><span class="line"><span class="comment">        * 14:34:51.478 [main] INFO com.cabbage.demos.CacheEvictionManager - [第1次访问] key = Bob, value = null</span></span><br><span class="line"><span class="comment">        * 14:34:52.989 [main] INFO com.cabbage.demos.CacheEvictionManager - [第2次访问] key = Bob, value = null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="4-4-采用定制化的缓存驱逐策略"><a href="#4-4-采用定制化的缓存驱逐策略" class="headerlink" title="4.4 采用定制化的缓存驱逐策略"></a>4.4 采用定制化的缓存驱逐策略</h6><ul>
<li><p>可以通过 Expiry 接口来实现，这个接口内部定义有如下的处理方法：expireAfterCreate，expireAfterUpdate，expireAfterRead，详细实现参考以下代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo04</span><span class="params">()</span> &#123;</span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .expireAfter(<span class="keyword">new</span> <span class="title class_">Expiry</span>&lt;String, String&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterCreate</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> String s2, <span class="type">long</span> l)</span> &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;[创建后失效计算 key = &#123;&#125;， value = &#123;&#125;]&quot;</span>, s, s2);</span><br><span class="line">                       <span class="comment">// 相当于创建后多少秒就失效了</span></span><br><span class="line">                       <span class="keyword">return</span> TimeUnit.NANOSECONDS.convert(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">                   &#125;</span><br><span class="line">  </span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterUpdate</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> String s2, <span class="type">long</span> l, <span class="meta">@NonNegative</span> <span class="type">long</span> l1)</span> &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;[更新后失效计算 key = &#123;&#125;， value = &#123;&#125;]&quot;</span>, s, s2);</span><br><span class="line">                       <span class="comment">// 更新完多少秒后就失效了</span></span><br><span class="line">                       <span class="keyword">return</span> TimeUnit.NANOSECONDS.convert(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                   &#125;</span><br><span class="line">  </span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterRead</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> String s2, <span class="type">long</span> l, <span class="meta">@NonNegative</span> <span class="type">long</span> l1)</span> &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;[读取后失效计算 key = &#123;&#125;， value = &#123;&#125;]&quot;</span>, s, s2);</span><br><span class="line">                       <span class="comment">// 读取完多少秒后就失效了</span></span><br><span class="line">                       <span class="keyword">return</span> TimeUnit.NANOSECONDS.convert(<span class="number">5</span>, TimeUnit.SECONDS);  <span class="comment">// 将2秒转成纳秒</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)   <span class="comment">// 第一步</span></span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lily= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lily&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Wang= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Wang&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lee= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [创建后失效计算 key = Bob， value = 已登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [创建后失效计算 key = Lily， value = 未登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [创建后失效计算 key = Wang， value = 未登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [创建后失效计算 key = Lee， value = 已登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [读取后失效计算 key = Bob， value = 已登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - 获取缓存数据，Bob= 已登录</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [读取后失效计算 key = Lily， value = 未登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - 获取缓存数据，Lily= 未登录</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [读取后失效计算 key = Wang， value = 未登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - 获取缓存数据，Wang= 未登录</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - [读取后失效计算 key = Lee， value = 已登录]</span></span><br><span class="line"><span class="comment">        * 14:51:23.040 [main] INFO com.cabbage.demos.CacheEvictionManager - 获取缓存数据，Lee= 已登录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="5-缓存数据的删除与监听"><a href="#5-缓存数据的删除与监听" class="headerlink" title="5. 缓存数据的删除与监听"></a>5. 缓存数据的删除与监听</h5><ul>
<li><p>手动删除一条数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span> &#123;</span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       cache.invalidate(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// 第一步，删除指定key的缓存</span></span><br><span class="line">       <span class="comment">// cache.invalidateAll();  // 删除所有缓存</span></span><br><span class="line">  </span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lily= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lily&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Wang= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Wang&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lee= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 输出结果</span></span><br><span class="line"><span class="comment">        * 11:20:37.978 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Bob= null</span></span><br><span class="line"><span class="comment">        * 11:20:37.980 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Lily= 未登录</span></span><br><span class="line"><span class="comment">        * 11:20:37.980 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Wang= 未登录</span></span><br><span class="line"><span class="comment">        * 11:20:37.980 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Lee= 已登录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除监听，删除数据之前可以通过监听进行一些操作</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span> &#123;</span><br><span class="line">       Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .removalListener(<span class="keyword">new</span> <span class="title class_">RemovalListener</span>&lt;String, String&gt;() &#123;  <span class="comment">// 第一步，设置监听器，删除时触发，removalCause是删除的原因</span></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(<span class="meta">@Nullable</span> String s, <span class="meta">@Nullable</span> String s2, <span class="meta">@NonNull</span> RemovalCause removalCause)</span> &#123;</span><br><span class="line">                       log.info(<span class="string">&quot;【数据删除监听】key = &#123;&#125;， value = &#123;&#125;, cause = &#123;&#125;&quot;</span>, s, s2, removalCause);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       cache.invalidate(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// 删除指定key的缓存</span></span><br><span class="line">       <span class="comment">// cache.invalidateAll();  // 删除所有缓存</span></span><br><span class="line">  </span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Bob= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lily= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lily&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Wang= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Wang&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;获取缓存数据，Lee= &#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 输出结果</span></span><br><span class="line"><span class="comment">        * 11:19:46.021 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Bob= null</span></span><br><span class="line"><span class="comment">        * 11:19:46.021 [ForkJoinPool.commonPool-worker-9] INFO com.cabbage.demos.CacheDelAndListener - 【数据删除监听】key = Bob， value = 已登录, cause = EXPLICIT</span></span><br><span class="line"><span class="comment">        * 11:19:46.024 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Lily= 未登录</span></span><br><span class="line"><span class="comment">        * 11:19:46.024 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Wang= 未登录</span></span><br><span class="line"><span class="comment">        * 11:19:46.024 [main] INFO com.cabbage.demos.CacheDelAndListener - 获取缓存数据，Lee= 已登录</span></span><br><span class="line"><span class="comment">    		 */</span> </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="6-CacheStats-缓存数据统计"><a href="#6-CacheStats-缓存数据统计" class="headerlink" title="6. CacheStats 缓存数据统计"></a>6. CacheStats 缓存数据统计</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存的 统计数据</span></span><br><span class="line"><span class="comment">   * 在使用数据统计的时候，Caffeine 内部使用了一个 StatsCounter 接口类型，</span></span><br><span class="line"><span class="comment">   * 最终如果要想实现数据的统计的处理操作，那么肯定是需要通过 StatsCounter 接口实现的，而这个接口提供有一个内置的并</span></span><br><span class="line"><span class="comment">   * 发数据统计的操作实现子类。</span></span><br><span class="line"><span class="comment">   * Cafeine 缓存组件除了提供有强大的缓存处理性能之外，也额外提供了一些缓存数据的统计功能，每当用户进行缓存数据操下时，</span></span><br><span class="line"><span class="comment">   * 都可以对这些操作记录的结果进行记录，这样就可以准确的知道缓存命中数、失效数、驱逐数等统计结果。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">              .maximumSize(<span class="number">100</span>)</span><br><span class="line">              .expireAfterAccess(<span class="number">1L</span>, TimeUnit.MILLISECONDS)  <span class="comment">// 设置1毫秒未读过期</span></span><br><span class="line">              .recordStats()</span><br><span class="line">              .build();</span><br><span class="line">      cache.put(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;已登录&quot;</span>);</span><br><span class="line">      cache.put(<span class="string">&quot;Lily&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">      cache.put(<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">      cache.put(<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;已登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此时设置的候选的KEY数据是有些不存在的，通过这些不存在的数据进行最终的非命中统计操作</span></span><br><span class="line">      String[] keys = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Wang&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;No1&quot;</span>, <span class="string">&quot;no2&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">// 定义随机数</span></span><br><span class="line">      <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys[random.nextInt(keys.length)]; <span class="comment">// 随机选取一个key</span></span><br><span class="line">              log.info(<span class="string">&quot;key = &#123;&#125;, value = &#123;&#125;&quot;</span>, key,cache.getIfPresent(key));</span><br><span class="line">          &#125;,<span class="string">&quot;查询线程 - &quot;</span>+i).start();</span><br><span class="line">      &#125;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">// 让多线程执行完</span></span><br><span class="line">      <span class="type">CacheStats</span> <span class="variable">stats</span> <span class="operator">=</span> cache.stats();</span><br><span class="line">      log.info(<span class="string">&quot;【CacheStats】缓存操作请求次数: &#123;&#125;&quot;</span>, stats.requestCount());</span><br><span class="line">      log.info(<span class="string">&quot;【CacheStats】缓存命中次数: &#123;&#125;&quot;</span>, stats.hitCount());</span><br><span class="line">      log.info(<span class="string">&quot;【Cachestats】缓存未命中次数: &#123;&#125;&quot;</span>, stats.missCount());</span><br><span class="line">      <span class="comment">//所有的缓存组件里面，最为重要的一项性能指标就是命中率的处理问题了</span></span><br><span class="line">      log.info(<span class="string">&quot;【CacheStats】缓存命中率: &#123;&#125;&quot;</span>, stats.hitRate());</span><br><span class="line">      log.info(<span class="string">&quot;【CacheStats】缓存驱逐次数: &#123;&#125;&quot;</span>, stats.evictionCount());</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 输出结果</span></span><br><span class="line"><span class="comment">       16:20:02.911 [main] INFO com.cabbage.demos.CacheStatsDemo - 【CacheStats】缓存操作请求次数: 1000</span></span><br><span class="line"><span class="comment">       16:20:02.911 [main] INFO com.cabbage.demos.CacheStatsDemo - 【CacheStats】缓存命中次数: 13</span></span><br><span class="line"><span class="comment">       16:20:02.911 [main] INFO com.cabbage.demos.CacheStatsDemo - 【Cachestats】缓存未命中次数: 987</span></span><br><span class="line"><span class="comment">       16:20:02.911 [main] INFO com.cabbage.demos.CacheStatsDemo - 【CacheStats】缓存命中率: 0.013</span></span><br><span class="line"><span class="comment">       16:20:02.911 [main] INFO com.cabbage.demos.CacheStatsDemo - 【CacheStats】缓存驱逐次数: 4</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Git设置多账号生成SSH公钥分别连接gitee和github</title>
    <url>/2024/11/08/Git%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5%E5%88%86%E5%88%AB%E8%BF%9E%E6%8E%A5gitee%E5%92%8Cgithub/</url>
    <content><![CDATA[<h3 id="一、本地Git设置账号"><a href="#一、本地Git设置账号" class="headerlink" title="一、本地Git设置账号"></a>一、本地Git设置账号</h3><ol>
<li><p>清空全局配置和历史数</p>
<p>由于需要设置多个账号，有全局账号需要清除，具体指令如下</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; git config --list <span class="comment"># 查看git配置</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global user.name <span class="comment"># 查看git全局账号</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global --<span class="built_in">unset</span> user.name <span class="comment"># 移除全局账号</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global user.email <span class="comment"># 查看git全局邮箱</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global --<span class="built_in">unset</span> user.email <span class="comment"># 移除全局邮箱</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global user.password <span class="comment"># 查看git全局密码</span></span><br><span class="line"></span><br><span class="line">&gt; git config --global --<span class="built_in">unset</span> user.password <span class="comment"># 移除全局密码</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">rm</span> -rf ~/.ssh <span class="comment"># 删除ssh密钥目录</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>生成SSH密钥</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-keygen -t rsa -C<span class="string">&#x27;邮箱账号&#x27;</span> -f ~/.ssh/gitee_rsa</span><br><span class="line">&gt; ssh-keygen -t rsa -C<span class="string">&#x27;邮箱账号&#x27;</span> -f ~/.ssh/github_rsa</span><br><span class="line"><span class="comment"># 输入命令后都是直接按回车键即可，生成的密钥路径一般是C:\Users\xxx\.ssh</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="二、远程Git仓库设置公钥"><a href="#二、远程Git仓库设置公钥" class="headerlink" title="二、远程Git仓库设置公钥"></a>二、远程Git仓库设置公钥</h3><ol>
<li><p>gitee设置公钥</p>
<ol>
<li><p>到C:\Users\xxx.ssh目录下，用文本打开gitee_rsa.pub，复制文本里的所有内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411081848836.png"
                     
                ></p>
</li>
</ol>
<p>​	登录gitee官网，打开 设置-&gt;公钥，将公钥粘贴，标题调整下 点击 确定 即可，如下：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411081849913.png"
                     
                >	</p>
</li>
<li><p>github设置公钥</p>
<p>同理，用文本打开github_rsa.pub，复制文本里的所有内容，登录github官网，进入 settings -》SSH and GPG keys -》 New SSH key 粘贴后保存即可。</p>
</li>
</ol>
<p>三、本地Git配置账号主机</p>
<p>​	在.ssh目录下新建config文件，编辑如下配置：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411081851670.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 描述</span><br><span class="line"># Host 网站地址或者ip地址</span><br><span class="line"># HostName 网站地址，可以不填</span><br><span class="line"># User 可以写邮箱名称，也可以写git账号</span><br><span class="line"># PreferredAuthentications 认证方式，可以不填</span><br><span class="line"># IdentityFile 对应密钥路径</span><br></pre></td></tr></table></figure></div>

<p>测试配置是否成功</p>
<p>​	ssh -T <a class="link"   href="mailto:git@gitee.com" >git@gitee.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>​	ssh -T <a class="link"   href="mailto:git@github.com" >git@github.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411081853729.png"
                     
                ></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpSevletRequest Body信息不能被多次读取的问题</title>
    <url>/2024/12/18/HttpSevletRequest%20Body%E4%BF%A1%E6%81%AF%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%8F%96%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在 Java Web 开发中，HTTP 请求体是客户端向服务器发送数据的主要载体，例如表单提交、JSON 数据等。当服务器收到请求后，通常通过 <code>HttpServletRequest</code> 类获取请求体的内容。然而，HTTP 请求体通常只能被读取一次。这是因为请求体使用输入流（<code>InputStream</code>）进行读取，一旦读取完毕，流的位置就会到达流的末尾，无法再读取。因此，在开发中，如果不小心读取了请求体一次，后续的代码将无法访问请求体数据，从而导致数据丢失或者异常。</p>
<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><h4 id="HTTP-请求体的读取限制"><a href="#HTTP-请求体的读取限制" class="headerlink" title="HTTP 请求体的读取限制"></a>HTTP 请求体的读取限制</h4><p>HTTP 请求体（如 POST 请求中的 JSON 数据或表单数据）是通过输入流（<code>InputStream</code>）传输的。Servlet 容器在接收到请求时，会将输入流读取并解析到内存中，然后进行后续的处理。但是，HTTP 请求体的流一次性读取特性意味着：</p>
<ol>
<li><strong>只能读取一次</strong>：一旦读取完请求体的数据，流的位置就会指向末尾，无法再次读取同一数据。</li>
<li><strong>重复访问时失败</strong>：如果在请求处理过程中，多个组件或方法需要访问请求体数据，但该数据已经被读取过一次，那么后续的读取操作将无法成功，通常会抛出异常或返回空数据。</li>
</ol>
<p>这种问题在需要多次读取请求体的场景中尤为明显。例如，在拦截器或过滤器中读取请求体数据时，后续的业务处理方法（如 Controller）可能无法再访问请求体。</p>
<h3 id="2-问题产生的场景"><a href="#2-问题产生的场景" class="headerlink" title="2. 问题产生的场景"></a>2. 问题产生的场景</h3><p>以下是一些常见的导致请求体只能读取一次的场景：</p>
<ul>
<li><strong>使用 Servlet 读取请求体</strong>：当使用 <code>HttpServletRequest</code> 获取请求体时，流会被消耗，无法再次获取。</li>
<li><strong>Spring MVC 中的 @RequestBody</strong>：Spring MVC 提供了 <code>@RequestBody</code> 注解，用于直接将请求体映射为 Java 对象。但一旦请求体被映射，流就会被消耗，导致后续无法再访问请求体数据。</li>
<li><strong>自定义过滤器或拦截器</strong>：在一些需要多次读取请求体的场景下，过滤器或拦截器读取请求体后，后续代码无法再次访问请求体数据。</li>
</ul>
<h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><h4 id="使用-HttpServletRequestWrapper-包装请求体"><a href="#使用-HttpServletRequestWrapper-包装请求体" class="headerlink" title="使用 HttpServletRequestWrapper 包装请求体"></a>使用 <code>HttpServletRequestWrapper</code> 包装请求体</h4><p>通过创建一个自定义的 <code>HttpServletRequestWrapper</code> 来缓存请求体的数据，并提供多次读取的能力。这种方式允许请求体数据在第一次读取时被缓存，后续的请求处理流程可以从缓存中读取数据。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.wj0410.zcscloud.framework.web.core.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.extra.servlet.ServletUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ReadListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Request Body 缓存 Wrapper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRequestBodyWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheRequestBodyWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        body = ServletUtil.getBodyBytes(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="built_in">this</span>.getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body);</span><br><span class="line">        <span class="comment">// 返回 ServletInputStream</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> inputStream.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener readListener)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> body.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.wj0410.zcscloud.framework.web.core.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request Body 缓存 Filter，实现它的可重复读取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRequestBodyFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        filterChain.doFilter(<span class="keyword">new</span> <span class="title class_">CacheRequestBodyWrapper</span>(request), response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldNotFilter</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 只处理 json 请求内容</span></span><br><span class="line">        <span class="keyword">return</span> !isJsonRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isJsonRequest</span><span class="params">(ServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrUtil.startWithIgnoreCase(request.getContentType(), 		MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.wj0410.zcscloud.framework.web.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.wj0410.zcscloud.framework.common.enums.WebFilterOrderEnum;</span><br><span class="line"><span class="keyword">import</span> io.github.wj0410.zcscloud.framework.web.core.filter.CacheRequestBodyFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 RequestBodyCacheFilter Bean，可重复读取请求内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;CacheRequestBodyFilter&gt; <span class="title function_">requestBodyCacheFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createFilterBean(<span class="keyword">new</span> <span class="title class_">CacheRequestBodyFilter</span>(), WebFilterOrderEnum.REQUEST_BODY_CACHE_FILTER);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Filter</span>&gt; FilterRegistrationBean&lt;T&gt; <span class="title function_">createFilterBean</span><span class="params">(T filter, Integer order)</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;T&gt; bean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(filter);</span><br><span class="line">        bean.setOrder(order);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.wj0410.zcscloud.framework.common.enums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Web 过滤器顺序的枚举类，保证过滤器按照符合我们的预期</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  考虑到每个 starter 都需要用到该工具类，所以放到 common 模块下的 enum 包下</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebFilterOrderEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">REQUEST_BODY_CACHE_FILTER</span> <span class="operator">=</span> Integer.MIN_VALUE + <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora for Mac 免激活版</title>
    <url>/2024/11/03/Mac%E5%AE%89%E8%A3%85%E6%BF%80%E6%B4%BBTypora/</url>
    <content><![CDATA[<p>链接: <a class="link"   href="https://pan.baidu.com/s/1gynKmIZ3EWOwMJ2RPZeh3g?pwd=fxxi" >https://pan.baidu.com/s/1gynKmIZ3EWOwMJ2RPZeh3g?pwd=fxxi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>提取码: fxxi</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo使用GitHub图床</title>
    <url>/2024/11/03/PicGo%E4%BD%BF%E7%94%A8GitHub%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>文档地址：<a class="link"   href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" >PicGo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring validation 分组校验用法</title>
    <url>/2024/11/19/Spring%20validation%20%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在使用 <code>Java Bean Validation</code> 进行参数校验的时候，很多场景下的一个Req实体都是同时满足多个业务，但是可能在不同的业务场景下，参数校验有细微的差别。例如在新增用户和编辑用户的场景下，UserReq实体相同，但是编辑的时候用户ID是必填的。如果想要新增用户和编辑用户共用一个UserReq实体，就只能在id属性上去掉@NotNull注解，在编辑方法上手动判断，这样实际上比较麻烦，也不够优雅。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserReq</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="meta">@NotEmpty(message=&quot;name 不能为空&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@NotNull(message=&quot;age 不能为空&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> R <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserReq userReq)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> R <span class="title function_">edit</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserReq userReq)</span>&#123;</span><br><span class="line">    <span class="comment">// 手动判断id</span></span><br><span class="line">    <span class="keyword">if</span>(userReq.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(...)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果能给id字段上打一个记号，标识出id字段只需要编辑时校验，新增的时候忽视掉就好了。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实际上，@NotEmpty、@NotNull … 注解上有一个属性，叫做groups，用于指定一个验证分组。它允许你对同一个对象应用不同的验证规则，具体规则可以根据上下文的不同而有所不同。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(NotNull.List.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(</span></span><br><span class="line"><span class="meta">    validatedBy = &#123;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotNull &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;javax.validation.constraints.NotNull.message&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> List &#123;</span><br><span class="line">        NotNull[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>于是我们可以定义不同的验证分组接口，用于标识不同的验证场景。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">InsertGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">DeleteGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在Req实体的属性上标注出场景</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserReq</span> &#123;</span><br><span class="line">  <span class="meta">@NotNull(message=&quot;id不能为空&quot;, groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="meta">@NotEmpty(message=&quot;name不能为空&quot;, groups = &#123;InsertGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@NotNull(message=&quot;age不能为空&quot;, groups = &#123;InsertGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在Controller接口方法上制定验证的分组规则</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> R <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidGroup.InsertGroup.class)</span> UserReq userReq)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> R <span class="title function_">edit</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidGroup.UpdateGroup.class)</span> UserReq userReq)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就实现参数的优雅校验了。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot中优雅实现策略模式（一）</title>
    <url>/2024/11/08/Springboot%E4%B8%AD%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="策略模式简述"><a href="#策略模式简述" class="headerlink" title="策略模式简述"></a>策略模式简述</h3><p>策略模式的核心是将行为和行为的具体实现分离的模式，有以下特点：</p>
<p>可以避免代码中出现大量的if else判断<br>可以增加新的策略而不影响调用端的逻辑代码</p>
<h3 id="策略模式UML类图"><a href="#策略模式UML类图" class="headerlink" title="策略模式UML类图"></a>策略模式UML类图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411081131757.png"
                     
                ></p>
<p>核心思想是在业务使用处采用接口进行关系依赖，然后根据具体的策略选择具体的实现类执行相关的计算方法</p>
<h3 id="通过Springboot的功能快速实现策略模式"><a href="#通过Springboot的功能快速实现策略模式" class="headerlink" title="通过Springboot的功能快速实现策略模式"></a>通过Springboot的功能快速实现策略模式</h3><h4 id="功能需求描述"><a href="#功能需求描述" class="headerlink" title="功能需求描述"></a>功能需求描述</h4><p>需要通过统一的启动任务接口启动不同类型的任务，不同类型的任务启动方式不同，通过任务类型区分不同的任务进行启动</p>
<h4 id="策略模式接口定义"><a href="#策略模式接口定义" class="headerlink" title="策略模式接口定义"></a>策略模式接口定义</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TaskHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">taskType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskInfo 任务信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否启动成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Boolean <span class="title function_">start</span><span class="params">(TaskInfo taskInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskInfo 任务信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否停止成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Boolean <span class="title function_">stop</span><span class="params">(TaskInfo taskInfo)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>定义策略接口，包含三个方法：</p>
<p>taskType：获取任务类型，由具体策略实现类标记具体处理哪种类型的任务<br>start：启动任务<br>stop：终止任务</p>
<h4 id="具体策略实现类"><a href="#具体策略实现类" class="headerlink" title="具体策略实现类"></a>具体策略实现类</h4><ul>
<li><p>mysql任务策略类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlTaskHandler</span> <span class="keyword">implements</span> <span class="title class_">TaskHandler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taskType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mysql&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">start</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;mysql task start...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">stop</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;mysql task stopped...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>sqlserver策略实现类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlserverTaskHandler</span> <span class="keyword">implements</span> <span class="title class_">TaskHandler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taskType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sqlserver&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">start</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;sqlserver task start...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">stop</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;sqlserver task stopped...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="策略的注册与调用"><a href="#策略的注册与调用" class="headerlink" title="策略的注册与调用"></a>策略的注册与调用</h4><ul>
<li><p>策略注册</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskHandlerRegister</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, TaskHandler&gt; taskHandlerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, TaskHandler&gt; beansOfType = applicationContext.getBeansOfType(TaskHandler.class);</span><br><span class="line">        <span class="keyword">for</span> (TaskHandler taskHandler : beansOfType.values()) &#123;</span><br><span class="line">            taskHandlerMap.put(taskHandler.taskType(), taskHandler);</span><br><span class="line">            log.info(<span class="string">&quot;TaskHandler type:&#123;&#125; has been registered...&quot;</span>, taskHandler.taskType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据任务类型获取具体策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskType 任务类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 具体策略实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TaskHandler <span class="title function_">getTaskHandler</span><span class="params">(String taskType)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskHandler</span> <span class="variable">taskHandler</span> <span class="operator">=</span> taskHandlerMap.get(taskType);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(taskHandler)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;taskType:%s can not resolve&quot;</span>, taskType));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>CommandLineRunner接口：在SpringBoot项目初始化完成后执行该接口的run方法，可以用于做一些初始化操作，这里利用该方法进行策略的发现和注册，将策略的具体实现类通过Map进行缓存</p>
</li>
<li><p>ApplicationContextAware接口：实现该接口的类可以获取到Springboot的上下文执行环境ApplicationContext，通过上下文执行环境可以获取到SpringBoot容器中的Bean对象，这里通过applicationContext.getBeansOfType(TaskHandler.class)方法获取实现TaskHandler接口的所有实例Bean，即为该策略的全部实现</p>
</li>
<li><p>getTaskHandler方法：通过任务类型获取具体的策略实现类，便于在业务端进行调用</p>
</li>
</ul>
<h4 id="具体业务端调用策略"><a href="#具体业务端调用策略" class="headerlink" title="具体业务端调用策略"></a>具体业务端调用策略</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskHandlerRegister taskHandlerRegister;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskService</span><span class="params">(TaskHandlerRegister taskHandlerRegister)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskHandlerRegister = taskHandlerRegister;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">startTask</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">    	<span class="comment">// 通过任务类型获取到具体的任务处理类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskHandler</span> <span class="variable">taskHandler</span> <span class="operator">=</span> taskHandlerRegister.getTaskHandler(taskInfo.getTaskType());</span><br><span class="line">        <span class="comment">// 调用具体任务处理类的start方法启动任务</span></span><br><span class="line">        <span class="keyword">return</span> taskHandler.start(taskInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">stopTask</span><span class="params">(TaskInfo taskInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskHandler</span> <span class="variable">taskHandler</span> <span class="operator">=</span> taskHandlerRegister.getTaskHandler(taskInfo.getTaskType());</span><br><span class="line">        <span class="keyword">return</span> taskHandler.stop(taskInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在具体的业务端注入TaskHandlerRegister服务，在启动任务时通过任务类型获取到具体的实现策略，taskHandlerRegister.getTaskHandler(taskInfo.getTaskType());然后调用具体策略的具体方法。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从一次生产事故中提升编码素养</title>
    <url>/2024/12/13/%E4%BB%8E%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E4%B8%AD%E6%8F%90%E5%8D%87%E7%BC%96%E7%A0%81%E7%B4%A0%E5%85%BB/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近刚进项目组，正赶上项目组在总结生产事故，询问得知在一次双11上线过程中，由于新需求与现有接口入参相似度较高，考虑复用现有接口开发，最后上线完成后进行首单验证，触发故障，影响了线上业务。</p>
<h4 id="故障代码分析"><a href="#故障代码分析" class="headerlink" title="故障代码分析"></a>故障代码分析</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BaseResp&lt;Void&gt; <span class="title function_">xxxx</span><span class="params">(<span class="meta">@RequestBody</span> xxxx req)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xxx</span> <span class="operator">=</span> req.getxxx();</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> req.getxxx();</span><br><span class="line">    <span class="type">String</span> <span class="variable">xxx</span> <span class="operator">=</span> req.getxxx();</span><br><span class="line">    <span class="type">String</span> <span class="variable">xxx</span> <span class="operator">=</span> req.getxxx();</span><br><span class="line">    <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> req.getxxx();</span><br><span class="line">    <span class="comment">// 根据userName去查uid 开卡新工卡数据库是否存在uid相同且是待开卡的数据，如果存在就走新工卡开卡流程，否则走老工卡开卡流程</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isUsingNew</span> <span class="operator">=</span> getUsingNew(uid, userName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsingNew) &#123;</span><br><span class="line">            openNewCard(uid, userName, xxx, xxx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openOldCard(req);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改状态为已领卡</span></span><br><span class="line">    <span class="keyword">return</span> BaseResp.success(<span class="string">&quot;修改状态成功&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大家可以分析一下这段代码，细心的朋友很快便可以发现，在判断走新工卡开卡流程还是走老工卡开卡流程中，核心的参数为<strong>uid</strong>和<strong>userName</strong>，但是这两个参数都是通过前端传递的，我们都知道对于前端传递的参数，一定是不可信的，后端一定要做校验，特别还是这种会影响业务流转的参数。</p>
<h4 id="引发的后果"><a href="#引发的后果" class="headerlink" title="引发的后果"></a>引发的后果</h4><p>最终，因为没有对参数进行校验，后续代码逻辑还有通用的查询还有删除逻辑，由于调用的通用方法，uid为空没有做条件拼接，导致大量数据被删除，引发灾难后果。开发团队连续3天没有休息，才完成对数据的恢复，上线时间也推迟了3周。</p>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>对于这次的生产事故，表面上是对参数校验的疏忽，本质上我认为是编码素养的问题。方法复用的确能够显著减少代码冗余，提高代码的可维护性和可读性，但如果方法复用不当，尤其是在错误的地方复用，可能会引发一些问题，甚至导致程序的bug或者逻辑错误。</p>
<ul>
<li><p><strong>接口设计</strong></p>
<ul>
<li><p>接口单一职责原则</p>
<p>假设有一个方法用于计算价格，后来在另一个场景中复用，结果导致了错误。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原方法：计算商品价格</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePrice</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> order.getBasePrice();</span><br><span class="line">        <span class="keyword">if</span> (order.isMember()) &#123;</span><br><span class="line">            price *= <span class="number">0.9</span>; <span class="comment">// 会员折扣</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误复用：计算运费时复用价格计算方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShippingCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateShipping</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceCalculator</span>().calculatePrice(order);</span><br><span class="line">        <span class="keyword">if</span> (order.getWeight() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            price += <span class="number">20</span>; <span class="comment">// 加运费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;  <span class="comment">// 错误：将价格计算和运费计算混淆了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>calculatePrice</code> 方法是专门用来计算商品价格的，但是在 <code>ShippingCalculator</code> 中错误地复用了 <code>calculatePrice</code> 方法，导致运费的计算与价格计算混在一起。这违背了单一职责原则，导致逻辑混乱。</p>
<p><strong>正确的复用例子</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原方法：计算商品价格</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePrice</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> order.getBasePrice();</span><br><span class="line">        <span class="keyword">if</span> (order.isMember()) &#123;</span><br><span class="line">            price *= <span class="number">0.9</span>; <span class="comment">// 会员折扣</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设计：正确分开运费计算和价格计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShippingCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateShipping</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">shippingCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (order.getWeight() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            shippingCost = <span class="number">20</span>; <span class="comment">// 加运费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shippingCost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateTotal</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceCalculator</span>().calculatePrice(order);</span><br><span class="line">        <span class="type">double</span> <span class="variable">shipping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShippingCalculator</span>().calculateShipping(order);</span><br><span class="line">        <span class="keyword">return</span> price + shipping; <span class="comment">// 正确的复用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最少入参&#x2F;响应暴露原则</p>
<p>最少入参暴露原则的目的是<strong>减少接口暴露的参数数量</strong>，从而降低接口的复杂度，提高系统的安全性、可维护性和可扩展性。</p>
<p>最少响应暴露原则的目的是<strong>尽量减少接口返回的响应内容</strong>，确保返回的数据仅包含调用者所需要的信息，从而提高数据传输效率，并减少暴露不必要的敏感数据。</p>
</li>
<li><p>对于入参做必要的参数校验</p>
</li>
</ul>
</li>
<li><p><strong>核心（通用）接口设计</strong></p>
<ul>
<li>核心能力&#x2F;方法有必要参数校验</li>
<li>方法定义应该有明确的入参和响应</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次@NotEmpty失效问题</title>
    <url>/2024/11/13/%E8%AE%B0%E4%B8%80%E6%AC%A1@NotEmpty%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在接手一个新项目中，使用@NotEmpty注解无效，但是@NotNull注解却可以使用，百思不得其解，网上也查了一些资料，说springboot版本问题，让加<code>spring-boot-starter-validation</code>依赖，但是加了也没效果，Controller上加了@Validated注解，方法上也加了@Valid注解，都没效果。最后发现是因为<strong>早期的<code>Hibernate Validator</code>版本可能对@NotEmpty不支持</strong>，项目中正好也单独引入了<code>Hibernate Validator</code>，删除掉依赖后，使用<code>spring-boot-starter-validation</code>的依赖就好了。</p>
<blockquote>
<p>spring-boot-starter-validation 和Hibernate Validator的关系</p>
<p><code>spring-boot-starter-validation</code> 是 Spring Boot 的一个模块，它提供了数据验证的功能，而 Hibernate Validator 是数据验证的一个流行实现。</p>
<p>Spring Boot Starter Validation 模块依赖于 Hibernate Validator，并提供了一些方便的自动配置。Hibernate Validator 提供了基于 Bean 校验的 API，它支持 JSR-303 和 JSR-380 注解，这些注解可以被用来对 Java Beans 进行数据校验。</p>
<p>关系简单来说就是：</p>
<ul>
<li>Spring Boot Starter Validation 依赖于 Hibernate Validator。</li>
<li>Hibernate Validator 是一个数据校验的实现，提供了基于注解的数据校验方式。</li>
<li>Spring Boot Starter Validation 提供了自动配置和启动所需要的依赖。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习笔记</title>
    <url>/2021/11/04/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、索引的概述"><a href="#一、索引的概述" class="headerlink" title="一、索引的概述"></a>一、索引的概述</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1.为什么使用索引"></a>1.为什么使用索引</h2><p>在海量数据中进行查询某条记录的场景是经常发生的，如何提升查询性能，就跟要查询的数据字段是否有索引有关系。如果字段加了索引，那么查询的性能就会非常快！</p>
<ul>
<li>索引为什么快？</li>
<li>索引到底是什么？</li>
<li>使用索引需要注意什么？</li>
</ul>
<h2 id="2-索引是什么"><a href="#2-索引是什么" class="headerlink" title="2.索引是什么"></a>2.索引是什么</h2><p>查字典的方式？“树”shu–通过目录来查，能够快速定位到目标数据所在的页码。</p>
<p>没有使用索引的时候，数据的查询需要进行多次IO读写，这样的性能较差，这样的性能较差——全表扫描的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041007934.png"
                     
                ></p>
<p>疑问：</p>
<ul>
<li>索引存放的位置？</li>
<li>索引的分类及如何创建？</li>
<li>索引使用了哪种数据结构？各种数据结构的查询性能分析。</li>
</ul>
<h2 id="3-索引存放的位置"><a href="#3-索引存放的位置" class="headerlink" title="3.索引存放的位置"></a>3.索引存放的位置</h2><p>对于mac系统在&#x2F;usr&#x2F;local&#x2F;mysql文件夹中，对于win系统c:&#x2F;programdata&#x2F;mysql（隐藏文件夹）</p>
<ul>
<li>InnoDB存储引擎的表：将索引和数据存放在同一个文件里。*.ibd</li>
<li>MyISAM存储引擎的表：索引和数据分开两个文件来存储。索引：*.MYI； 数据： *.MYD</li>
</ul>
<h1 id="二、索引使用的数据结构"><a href="#二、索引使用的数据结构" class="headerlink" title="二、索引使用的数据结构"></a>二、索引使用的数据结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><p>线性的维护数据的顺序。</p>
<p>对于线性表来说，有两种数据结构来支撑：</p>
<ul>
<li><p>线性顺序表：相邻两个数据的逻辑关系和物理存放位置是相同的。（数组）</p>
</li>
<li><p>线性链式表：相邻两个数据的逻辑关系和物理存放位置没有关系。数据是有先后的逻辑关系，但是数据的物理存储位置并不连续。</p>
<ul>
<li><p>单向链表：能够通过当前节点找到下一个节点的位置，以此来维护链表的逻辑关系。</p>
<p>节点结构：数据内容+下一个数据的指针</p>
</li>
<li><p>双向链表：能够通过当前节点找到上一个或下一个节点的位置，双向都可找。</p>
<p>节点结构：上一个数据的指针+数据内容+下一个数据的指针</p>
</li>
</ul>
</li>
</ul>
<p>顺序表和链式表区别：</p>
<p>数组：进行数据的查询性能（可以通过数组的索引&#x2F;下标）：时间复杂度（比较次数）&#x2F;空间复杂度（算法需要使用多少个变量空间））。</p>
<p>数组的查询性能非常好：时间复杂度是O(1)。但是增删性能是非常差的。</p>
<p>链表：查询性能非常差：时间复杂度是O(n)。增删性能是非常好的。</p>
<h2 id="2-栈（电梯）和队列（排队）"><a href="#2-栈（电梯）和队列（排队）" class="headerlink" title="2.栈（电梯）和队列（排队）"></a>2.栈（电梯）和队列（排队）</h2><ul>
<li><p>顺序栈、链栈</p>
</li>
<li><p>顺序队列、链式队列</p>
</li>
</ul>
<h2 id="3-串-String"><a href="#3-串-String" class="headerlink" title="3.串 String"></a>3.串 String</h2><p>定长串（String)、动态串(StringBuilder、StringBuffer)</p>
<p>疑问：</p>
<ul>
<li>String、StringBuilder、StringBuffer的底层实现（char型数组存储）</li>
<li>StringBuilder、StringBuffer区别是什么。</li>
</ul>
<p>String对象一旦创建，其值是不能修改的，如果要修改，会重新开辟内存空间来存储修改之后的对象，即修改了String的引用。因为 String 的底层是用数组来存值的，数组长度不可改变这一特性导致了上述问题。如果我们在实际开发过程中需要对某个字符串进行频繁的修改，使用 String 就会造成内存空间的浪费</p>
<ul>
<li><p>应该怎样解决这个问题呢？</p>
<p>‌StringBuffer。</p>
</li>
</ul>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>‌StringBuffer 和 String 类似，底层也是用一个数组来存储字符串的值，并且数组的默认长度为 16，即一个空的 StringBuffer 对象，数组长度为 16。实例化一个 StringBuffer 对象即创建了一个大小为 16 个字符的字符串缓冲区。但是当我们调用有参构造函数创建一个 StringBuffer 对象时，数组长度就不再是 16 了，而是根据当前对象的值来决定数组的长度，数组的长度为“当前对象的值的长度+16”。所以一个 StringBuffer 创建完成之后，有 16 个字符的空间可以对其值进行修改。如果修改的值范围超出了 16 个字符，会先检查StringBuffer 对象的原 char 数组的容量能不能装下新的字符串，如果装不下则会对 char 数组进行扩容。</p>
<ul>
<li><p>那StringBuffer是怎样进行扩容的呢？</p>
<p>扩容的逻辑就是创建一个新的 char 数组，将现有容量扩大一倍再加上2，如果还是不够大则直接等于需要的容量大小。扩容完成之后，将原数组的内容复制到新数组，最后将指针指向新的 char 数组。</p>
</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder 和 StringBuffer 拥有同一个父类 AbstractStringBuilder，同时实现的接口也是完全一样，都实现了java.io.Serializable, CharSequence 两个接口。</p>
<ul>
<li><p>那它俩有什么区别呢？</p>
<p>最大的区别在于 StringBuffer 对几乎所有的方法都实现了同步，线程比较安全，在多线程系统中可以保证数据同步；而StringBuilder 没有实现同步，线程不安全，在多线程系统中不能使用 StringBuilder。</p>
</li>
</ul>
<h3 id="StringBuffer和StringBuilder-的使用场景"><a href="#StringBuffer和StringBuilder-的使用场景" class="headerlink" title="StringBuffer和StringBuilder 的使用场景"></a>StringBuffer和StringBuilder 的使用场景</h3><p>当需要考虑线程安全的场景下使用 StringBuffer，如果不需要考虑线程安全，追求效率的场景下可以使用 StringBuilder。</p>
<h2 id="4-数组和广义表"><a href="#4-数组和广义表" class="headerlink" title="4.数组和广义表"></a>4.数组和广义表</h2><p>广义表：更加灵活的多维数组，可以在不同的元素中创建不同的维度的数组。</p>
<h2 id="5-树"><a href="#5-树" class="headerlink" title="5.树"></a>5.树</h2><p>查找树的查找性能是明显比线性表的性能要好。</p>
<h3 id="1）多叉树：非二叉树"><a href="#1）多叉树：非二叉树" class="headerlink" title="1）多叉树：非二叉树"></a>1）多叉树：非二叉树</h3><h3 id="2）二叉树：一个节点最多只能有2个子节点。可以是-0、1、2个子节点。"><a href="#2）二叉树：一个节点最多只能有2个子节点。可以是-0、1、2个子节点。" class="headerlink" title="2）二叉树：一个节点最多只能有2个子节点。可以是 0、1、2个子节点。"></a>2）二叉树：一个节点最多只能有2个子节点。可以是 0、1、2个子节点。</h3><h3 id="3）二叉查找树：二叉查找树的查找性能是ok的，查询性能跟树的高度有关，树的高度又跟插入的数据的顺序有关。"><a href="#3）二叉查找树：二叉查找树的查找性能是ok的，查询性能跟树的高度有关，树的高度又跟插入的数据的顺序有关。" class="headerlink" title="3）二叉查找树：二叉查找树的查找性能是ok的，查询性能跟树的高度有关，树的高度又跟插入的数据的顺序有关。"></a>3）二叉查找树：二叉查找树的查找性能是ok的，查询性能跟树的高度有关，树的高度又跟插入的数据的顺序有关。</h3><p>特点：根节点的数值比所有左子树的节点的数值大，比右子树的节点的数值小。这样的规律同样满足他的所有子树。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041009427.png"
                     
                ></p>
<h3 id="4）平衡二叉树（AVL树）（理想概念的树）：二叉查找树不能非常智能的维护树的高度，因此二叉查找树在某些情况下性能是不ok的，因此平衡二叉树出现了。"><a href="#4）平衡二叉树（AVL树）（理想概念的树）：二叉查找树不能非常智能的维护树的高度，因此二叉查找树在某些情况下性能是不ok的，因此平衡二叉树出现了。" class="headerlink" title="4）平衡二叉树（AVL树）（理想概念的树）：二叉查找树不能非常智能的维护树的高度，因此二叉查找树在某些情况下性能是不ok的，因此平衡二叉树出现了。"></a>4）平衡二叉树（AVL树）（理想概念的树）：二叉查找树不能非常智能的维护树的高度，因此二叉查找树在某些情况下性能是不ok的，因此平衡二叉树出现了。</h3><ul>
<li><p>特点：平衡二叉树中的树及其所有子树都应该满足：左子树和右子树的深度差不超过1。如果平衡二叉树不满足这个特点，那么平衡二叉树要进行自己旋转，如何自己旋转：</p>
<p>左旋：树右边过深，将右边中间节点作为根节点，往左边旋转，即可平衡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041009653.png"
                     
                ></p>
<p>右旋：树左边过深，将左边中间节点作为根节点，往右边旋转，即可平衡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041009951.png"
                     
                ></p>
<p>双向（先左后右、先右后左）：旋转一次无法平衡的情况。看左右哪边过深，执行先左后右或先右后左旋转。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041010680.png"
                     
                ></p>
</li>
</ul>
<h3 id="5）红黑树（平衡二叉树的一种体现）"><a href="#5）红黑树（平衡二叉树的一种体现）" class="headerlink" title="5）红黑树（平衡二叉树的一种体现）"></a>5）<strong>红黑树（平衡二叉树的一种体现）</strong></h3><p>平衡二叉树为了维护树的平衡，在一旦不满足平衡的情况下就要进行自旋，但是自旋会造成一定的系统开销。因此红黑树在自旋造成的系统开销和减少查询次数之间做了权衡。因此红黑树有时候并不是一颗平衡二叉树。</p>
<p>特点：</p>
<p>​	1.节点是红色或者黑色。</p>
<p>​	2.根节点是黑色。</p>
<p>​	3.不可能有连在一起的红色节点。</p>
<p>​	4.每个红色节点的两个子节点都是黑色。</p>
<p>​	5.叶子节点都是黑色（nil-黑色的空节点）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041010366.png"
                      alt="image-202411041010366" style="zoom:50%;" 
                >

<p>红黑树已经是在查询性能上得到了优化，但索引依然没有使用红黑树作为数据结构来存储数据，因为红黑树在每一层上存放的数据内容是有限的，导致数据量一大，树的深度就变得非常大，查询性能就会非常差。因此索引没有使用红黑树。</p>
<h3 id="6）B树"><a href="#6）B树" class="headerlink" title="6）B树"></a>6）B树</h3><p>B树允许一个节点存放多个数据，这样可以使更小的树的深度来存放更多的数据。但是，<span style="color:red">B树的一个节点中到底能存放多少个数据，决定了树的深度</span></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041011198.png"
                      alt="image-202411041011198" style="zoom:50%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041020579.png"
                     
                ></p>
<p>通过数值计算，B树的一个节点最多只能存放15个数据，因此B树依然不能满足海量数据的查询优化。</p>
<h3 id="7）B-树"><a href="#7）B-树" class="headerlink" title="7）B+树"></a>7）B+树</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041021199.png"
                     
                ></p>
<p>B+树的特点：</p>
<p>​	1.非叶子节点冗余了叶子节点中的键。</p>
<p>​	2.叶子节点是从小到大、从左到右排列的。</p>
<p>​	3.叶子节点之间提供了指针，提高了区间访问的性能。（缓存）</p>
<p>​	4.只有叶子节点存放数据，非叶子节点是不存放数据的，只存放键。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041013632.png"
                      alt="image-202411041013632" 
                >

<h3 id="8）哈希表"><a href="#8）哈希表" class="headerlink" title="8）哈希表"></a>8）哈希表</h3><p>使用哈希表来存储数据的性能是最快的，查找时间复杂度O(1)，但是不支持范围查找（区间访问）</p>
<h1 id="三、InnoDB和MyISAM的区别"><a href="#三、InnoDB和MyISAM的区别" class="headerlink" title="三、InnoDB和MyISAM的区别"></a>三、InnoDB和MyISAM的区别</h1><p>InnoDB和MyISAM都是数据库表的存储引擎。在互联网公司，或者追求查询性能的场景下，都会使用InnoDB作为表的存储引擎。</p>
<p>为什么？</p>
<h2 id="1-InnoDB引擎"><a href="#1-InnoDB引擎" class="headerlink" title="1.InnoDB引擎"></a>1.InnoDB引擎</h2><p>把索引和数据存放在一个文件中，通过找到索引后就能直接在索引树上的叶子节点中获得完整的数据。——聚簇索引</p>
<p>可以实现行锁&#x2F;表锁</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041013760.png"
                     
                ></p>
<h2 id="2-MyISAM存储引擎"><a href="#2-MyISAM存储引擎" class="headerlink" title="2.MyISAM存储引擎"></a>2.MyISAM存储引擎</h2><p>把索引和数据存放在两个文件中，查找到索引后还要去另一个文件中找数据，性能会慢一些——非聚簇索引。</p>
<p>除此之外，MyISAM天然支持表锁，而且支持全文索引。</p>
<h1 id="四、索引常见的面试题"><a href="#四、索引常见的面试题" class="headerlink" title="四、索引常见的面试题"></a>四、索引常见的面试题</h1><h2 id="问题1：为什么非主键索引的叶子节点存放的数据是主键值"><a href="#问题1：为什么非主键索引的叶子节点存放的数据是主键值" class="headerlink" title="问题1：为什么非主键索引的叶子节点存放的数据是主键值"></a>问题1：为什么非主键索引的叶子节点存放的数据是主键值</h2><p>1.数据冗余，虽然提升了查询性能，但是需要更多的空间来存放冗余的数据，造成空间的浪费。</p>
<p>2.维护麻烦，一个地方修改了数据，需要在多棵索引树上修改。</p>
<h2 id="问题2：为什么InnoDB表必须创建主键"><a href="#问题2：为什么InnoDB表必须创建主键" class="headerlink" title="问题2：为什么InnoDB表必须创建主键"></a>问题2：为什么InnoDB表必须创建主键</h2><p>如果没有主键，MySQL优化器会给一个虚拟的主键，于是普通索引会使用这个虚拟主键——也会造成性能的开销。为了性能考虑和设计初衷，创建表的时候就应该创建主键。</p>
<h2 id="问题3：为什么使用主键时推荐使用整型的自增主键"><a href="#问题3：为什么使用主键时推荐使用整型的自增主键" class="headerlink" title="问题3：为什么使用主键时推荐使用整型的自增主键"></a>问题3：为什么使用主键时推荐使用整型的自增主键</h2><h3 id="1）为什么使用整型"><a href="#1）为什么使用整型" class="headerlink" title="1）为什么使用整型"></a>1）为什么使用整型</h3><p>主键索引树，树里的叶子节点和非叶子节点的键存放的是主键的值，而且这颗树是一个二叉查找树。数据的存放是有大小顺序的。</p>
<ul>
<li>整型：大小顺序是很好比较的。</li>
<li>字符串：字符串的自然顺序的比较是要进行一次编码成为数值后再进行比较的。（字符串的自然顺序 A &lt; Z）</li>
</ul>
<h3 id="2）为什么自增"><a href="#2）为什么自增" class="headerlink" title="2）为什么自增"></a>2）为什么自增</h3><p>如果不用自增，那么主键索引树会使用更多的自旋次数来保证索引树的叶子节点中的数据是从小到大，从左到右排列，因此性能必然比使用了自增主键的性能要差！</p>
<h1 id="五、联合索引和最左前缀法则"><a href="#五、联合索引和最左前缀法则" class="headerlink" title="五、联合索引和最左前缀法则"></a>五、联合索引和最左前缀法则</h1><h2 id="1-联合索引的特点"><a href="#1-联合索引的特点" class="headerlink" title="1.联合索引的特点"></a>1.联合索引的特点</h2><p>使用一个索引来实现多个表中字段的索引效果。</p>
<h2 id="2-联合索引是如何存储的"><a href="#2-联合索引是如何存储的" class="headerlink" title="2.联合索引是如何存储的"></a>2.联合索引是如何存储的</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041014811.png"
                      alt="image-202411041014811" style="zoom:50%;" 
                >

<h2 id="3-最左前缀法则"><a href="#3-最左前缀法则" class="headerlink" title="3.最左前缀法则"></a>3.最左前缀法则</h2><p>最左前缀法则是表示一条sql语句在联合索引中有没有走索引（命中索引&#x2F;不会全表扫描）	</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041014810.png"
                      
                >

<h1 id="六、SQL优化"><a href="#六、SQL优化" class="headerlink" title="六、SQL优化"></a>六、SQL优化</h1><p>SQL优化的目的是为了SQL语句能够具备优秀的查询性能，实现这样的目的有很多途径：</p>
<ul>
<li>工程优化如何实现：数据库标准、表的结构标准、字段的标准、创建索引</li>
<li>SQL语句的优化：当前SQL语句有没有命中索引。</li>
</ul>
<h2 id="1-工程优化如何实现"><a href="#1-工程优化如何实现" class="headerlink" title="1.工程优化如何实现"></a>1.工程优化如何实现</h2><p>参考 <a class="link"   href="https://www.baidu.com/s?ie=UTF-8&wd=MySQL%E5%86%9B%E8%A7%84%E5%8D%87%E7%BA%A7%E7%89%88" >《MySQL军规升级版》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="2-Explain执行计划——SQL优化神器"><a href="#2-Explain执行计划——SQL优化神器" class="headerlink" title="2.Explain执行计划——SQL优化神器"></a>2.Explain执行计划——SQL优化神器</h2><p>得知道当前系统里有哪些SQL是慢SQL（查询性能超过1s的sql），再通过Explain工具，可以对当前SQL语句的性能进行判断——为什么慢，怎么解决。</p>
<p>要想知道哪些SQL是慢SQL，有两种方式：</p>
<ul>
<li><p>开启本地MySQL的慢日志查询日志。</p>
</li>
<li><p>阿里云提供的RDS（第三方部署的MySQL服务器），提供了查询慢SQL的功能。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;wangjie%&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>通过在SQL语句前面加上explain关键字，执行后并不会真正的执行sql语句本身，而是通过explain工具来分析当前这条SQL语句的性能细节：比如是什么样的查询类型、可能用到的索引及实际用到的索引，和一些额外的信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041015512.png"
                     
                ></p>
<h2 id="3-MySQL的内部优化器"><a href="#3-MySQL的内部优化器" class="headerlink" title="3.MySQL的内部优化器"></a>3.MySQL的内部优化器</h2><p>在SQL查询开始之前，MySQL内部优化器会进行一次自我优化，让这一次的查询性能尽可能的好。</p>
<p>当前执行的SQL：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> WARNINGS;</span><br></pre></td></tr></table></figure></div>

<p>内部优化器优化后的效果：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AS</span> `id`,<span class="string">&#x27;wangjie&#x27;</span> <span class="keyword">AS</span> `name`,<span class="string">&#x27;25&#x27;</span> <span class="keyword">AS</span> `age` <span class="keyword">from</span> `study`.`t_user` <span class="keyword">where</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<h2 id="4-select-type列"><a href="#4-select-type列" class="headerlink" title="4.select_type列"></a>4.select_type列</h2><p>关闭MySQL对衍生表的合并优化：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>执行了这样的计划：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041015253.png"
                      alt="image-202411041015253"  
                >

<ul>
<li><p>derived：</p>
<p>第一条执行的sql是from后面的字查询，该子查询只要在from后面，就会生成一张衍生表，因此他的查询类型：derived。</p>
</li>
<li><p>subquery：</p>
<p>在select之后from之前的子查询。</p>
</li>
<li><p>primary：</p>
<p>最外部的select。</p>
</li>
<li><p>simple：</p>
<p>不包含子查询的简单查询。</p>
</li>
<li><p>union:</p>
<p>使用union进行的联合查询。</p>
</li>
</ul>
<h2 id="5-table列"><a href="#5-table列" class="headerlink" title="5.table列"></a>5.table列</h2><p>当前查询正在查哪张表。</p>
<h2 id="6-type列"><a href="#6-type列" class="headerlink" title="6.type列"></a>6.type列</h2><p>type列可以直观的判断出当前的sql语句的性能。type里的取值和性能的优劣顺序如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span> <span class="operator">&gt;</span> <span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure></div>

<p>对于SQL优化来说，要尽量保证type列的值是属于range级别级以上。</p>
<ul>
<li><p>null</p>
<p>性能是最好的，一般在使用了聚合函数操作索引列，结果直接从索引树获取即可，因此性能是最好的。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> t_user </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041015294.png"
                     
                ></p>
</li>
<li><p>system</p>
<p>很少见。直接和一条记录进行匹配。</p>
</li>
<li><p>const</p>
<p>使用主键索引或唯一索引和常量进行比较，这种性能非常好。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041016089.png"
                     
                ></p>
</li>
<li><p>eq_ref</p>
<p>在进行多表连接查询时。如果查询条件是使用了主键进行比较，那么当前查询类型是eq_ref。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book_author a <span class="keyword">left</span> <span class="keyword">join</span> tb_book b <span class="keyword">on</span> a.book_id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>ref</p>
<ul>
<li><p>简单查询：</p>
<p>如果查询条件是普通列索引，那么类型ref</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;book1&#x27;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>复杂查询：</p>
<p>在进行连接查询时，如果查询条件是普通列索引，那么类型ref</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book_author a <span class="keyword">left</span> <span class="keyword">join</span> tb_book b <span class="keyword">on</span> a.book_id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>range</p>
<p>使用索引进行范围查找</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>index</p>
<p>查询没有进行条件判断。但是所有的数据都可以直接从索引树上获取。(book表中所有列都有索引)</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>all</p>
<p>没有走索引，进行了全表扫描。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_author</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="7-id列"><a href="#7-id列" class="headerlink" title="7.id列"></a>7.id列</h2><p>在多个select中，id越大越先执行，如果id相同。上面先执行。</p>
<h2 id="8-possible-keys列"><a href="#8-possible-keys列" class="headerlink" title="8.possible keys列"></a>8.possible keys列</h2><p>这一次的查询可能会用到的索引。也就是说mysql内部优化器会进行判断，如果这一次查询走索引的性能比全表扫描的性能要差，那么内部优化器就让此次查询进行全表扫描——这样的判断依据可以通过trance工具来查看。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;custome%&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>这条sql走索引查询的行数是500多万，那么总的数据行数也就500多万，走索引还需要回表查询，因此直接进行全表扫描性能更快。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041016269.png"
                     
                ></p>
<h2 id="9-key列"><a href="#9-key列" class="headerlink" title="9.key列"></a>9.key列</h2><p>实际该sql语句使用的索引</p>
<h2 id="10-rows列"><a href="#10-rows列" class="headerlink" title="10.rows列"></a>10.rows列</h2><p>该sql语句可能要查询的数据条数</p>
<h2 id="11-key-len列"><a href="#11-key-len列" class="headerlink" title="11.key_len列"></a>11.key_len列</h2><p>键的长度，通过这一列可以让我们知道当前命中了联合索引中的哪几列。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041016160.png"
                     
                ></p>
<p>name长度是74，也就是当看到key_len是74，表示使用了联合索引中的name列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041017102.png"
                     
                ></p>
<p>计算规则：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> 字符串</span><br><span class="line"><span class="number">1.</span><span class="type">char</span>(n)：n字节长度</span><br><span class="line"><span class="number">2.</span><span class="type">varchar</span>(n)：<span class="number">2</span>字节存储字符串长度，如果是utf<span class="number">-8</span>,则长度<span class="number">3</span>n<span class="operator">+</span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 数值类型</span><br><span class="line"><span class="number">1.</span>tinyint：<span class="number">1</span>字节</span><br><span class="line"><span class="number">2.</span><span class="type">smallint</span>：<span class="number">2</span>字节</span><br><span class="line"><span class="number">3.</span><span class="type">int</span>：<span class="number">4</span>字节</span><br><span class="line"><span class="number">4.</span><span class="type">bigint</span>：<span class="number">8</span>字节</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 时间类型</span><br><span class="line"><span class="number">1.</span><span class="type">date</span>：<span class="number">3</span>字节</span><br><span class="line"><span class="number">2.</span><span class="type">timestamp</span>：<span class="number">4</span>字节</span><br><span class="line"><span class="number">3.</span>datetime：<span class="number">8</span>字节</span><br><span class="line"></span><br><span class="line">如果字段允许<span class="keyword">NULL</span>，需要<span class="number">1</span>字节记录是否为<span class="keyword">NULL</span></span><br><span class="line">索引最大长度是<span class="number">768</span>字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引（前缀索引）</span><br></pre></td></tr></table></figure></div>

<h2 id="12-extra列"><a href="#12-extra列" class="headerlink" title="12.extra列"></a>12.extra列</h2><p>extra列提供了额外的信息，是能够帮助我们判断当前sql是否使用了覆盖索引、文件排序、使用了索引进行查询条件等等的信息。</p>
<ul>
<li><p>Using index：使用了覆盖索引。</p>
<p>所谓的覆盖索引，指的是当前查询的所有数据字段都是索引列，这就意味着可以直接从索引列中获取数据，而不需要回表查询。使用覆盖索引进行性能优化这种手段是之后sql优化经常要用到的。	</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> book_id,author_id <span class="keyword">from</span> tb_book_author <span class="keyword">where</span> book_id <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 覆盖索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book_author <span class="keyword">where</span> book_id <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 没有使用覆盖索引</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Using where</p>
<p>使用了普通索引列做查询条件。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_author <span class="keyword">where</span> name <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Using index condition</p>
<p>查询结果没有使用覆盖索引，建议可以使用覆盖索引来优化。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_author <span class="keyword">where</span> book_id <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Using temporary</p>
<p>在非索引列上进行去重操作就需要使用一张临时表来实现，性能是非常差的。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> tb_author</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Using filesort</p>
<p>使用文件排序：会使用磁盘+内存的方式进行文件排序，会涉及到两个概念：<a href="#dlpx">单路排序</a>、<a href="#slpx">双路排序</a>。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_author <span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>select tables optimized away</p>
<p>直接在索引列上进行聚合函数的操作，没有进行任何的表操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> tb_book</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="七、Trance工具"><a href="#七、Trance工具" class="headerlink" title="七、Trance工具"></a>七、Trance工具</h1><p>在执行计划中，我们发现有的sql会走索引，有的sql即使明确使用了索引也不会走索引。这是因为mysql的内部优化器认为走索引的性能比不走索引全表扫描的性能要差，因此mysql内部优化器选择了使用全表扫描。依据来自于trace工具的结论。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set session optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; -- 会话级别临时开启，只在当前会话生效。</span><br><span class="line">select * from t_student where std_name &gt; &#x27;a&#x27; order by age; -- 执行查询</span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE; -- 获得trace的分析结果</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;  -- 第一阶段：SQL准备阶段，格式化sql</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `t_student`.`id` AS `id`,`t_student`.`std_name` AS `std_name`,`t_student`.`age` AS `age`,`t_student`.`class_id` AS `class_id`,`t_student`.`gmt_create` AS `gmt_create` from `t_student` where (`t_student`.`std_name` &gt; &#x27;a&#x27;) order by `t_student`.`age`&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_preparation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;  -- 第二阶段：SQL优化阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;  -- 条件处理</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              &quot;original_condition&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* steps */</span><br><span class="line">            &#125; /* condition_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">            &#125; /* substitute_generated_columns */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;table_dependencies&quot;: [  -- 表依赖详情</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                &quot;map_bit&quot;: 0,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] /* depends_on_map_bits */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* table_dependencies */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] /* ref_optimizer_key_uses */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;rows_estimation&quot;: [  -- 预估表的访问成本</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;   -- 全表扫描</span><br><span class="line">                    &quot;rows&quot;: 100300,  -- 行数</span><br><span class="line">                    &quot;cost&quot;: 20351  -- 查询消耗</span><br><span class="line">                  &#125; /* table_scan */,</span><br><span class="line">                  &quot;potential_range_indexes&quot;: [  -- 查询可能使用的索引</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,  -- 主键索引</span><br><span class="line">                      &quot;usable&quot;: false,  -- 未使用</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;  -- 原因：不适合</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_std_age&quot;,  -- age索引</span><br><span class="line">                      &quot;usable&quot;: false,  -- 未使用</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;  -- 原因：不适合</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_std_name_age_class&quot;,  -- stdname,age,class的组合索引</span><br><span class="line">                      &quot;usable&quot;: true,  -- 使用</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;std_name&quot;,</span><br><span class="line">                        &quot;age&quot;,</span><br><span class="line">                        &quot;class_id&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* potential_range_indexes */,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] /* setup_range_conditions */,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;  -- group 用到的索引</span><br><span class="line">                    &quot;chosen&quot;: false,  -- 未使用</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;  -- 原因：未使用group by 或者 distinct</span><br><span class="line">                  &#125; /* group_index_range */,</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;   -- 分析各个索引使用成本</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        &quot;index&quot;: &quot;idx_std_name_age_class&quot;,</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;a &lt; std_name&quot;  -- 索引使用范围</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,  -- 使用该索引获取的记录是否按照主键排序</span><br><span class="line">                        &quot;using_mrr&quot;: false,</span><br><span class="line">                        &quot;index_only&quot;: false,  -- 是否使用覆盖索引</span><br><span class="line">                        &quot;rows&quot;: 50150,  -- 索引扫描行数</span><br><span class="line">                        &quot;cost&quot;: 60181,   -- 索引使用成本</span><br><span class="line">                        &quot;chosen&quot;: false,  -- 是否选择该索引：否</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;  -- 原因：消耗</span><br><span class="line">                      &#125;</span><br><span class="line">                    ] /* range_scan_alternatives */,</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;  -- 分析使用索引合并的成本</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                  &#125; /* analyzing_range_alternatives */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* rows_estimation */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;considered_execution_plans&quot;: [  -- 分析出的执行计划</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] /* plan_prefix */,</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;  -- 最优访问路径</span><br><span class="line">                  &quot;considered_access_paths&quot;: [  --分析出的最终访问路径</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: 100300,</span><br><span class="line">                      &quot;access_type&quot;: &quot;scan&quot;,  -- 访问类型：为scan，全表扫描</span><br><span class="line">                      &quot;resulting_rows&quot;: 100300,</span><br><span class="line">                      &quot;cost&quot;: 20349,</span><br><span class="line">                      &quot;chosen&quot;: true,  -- 确定选择</span><br><span class="line">                      &quot;use_tmp_table&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* considered_access_paths */</span><br><span class="line">                &#125; /* best_access_path */,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                &quot;rows_for_plan&quot;: 100300,</span><br><span class="line">                &quot;cost_for_plan&quot;: 20349,</span><br><span class="line">                &quot;sort_cost&quot;: 100300,</span><br><span class="line">                &quot;new_cost_for_plan&quot;: 120649,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* considered_execution_plans */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;   -- 为查询的表添加条件</span><br><span class="line">              &quot;original_condition&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] /* attached_conditions_computation */,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [    -- 添加条件结果</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;(`t_student`.`std_name` &gt; &#x27;a&#x27;)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* attached_conditions_summary */</span><br><span class="line">            &#125; /* attaching_conditions_to_tables */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;clause_processing&quot;: &#123;   -- order by 处理</span><br><span class="line">              &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">              &quot;original_clause&quot;: &quot;`t_student`.`age`&quot;,</span><br><span class="line">              &quot;items&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;item&quot;: &quot;`t_student`.`age`&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* items */,</span><br><span class="line">              &quot;resulting_clause_is_simple&quot;: true,</span><br><span class="line">              &quot;resulting_clause&quot;: &quot;`t_student`.`age`&quot;</span><br><span class="line">            &#125; /* clause_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;    -- 重构索引处理顺序</span><br><span class="line">              &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">              ] /* steps */,</span><br><span class="line">              &quot;index_order_summary&quot;: &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                &quot;index_provides_order&quot;: false,</span><br><span class="line">                &quot;order_direction&quot;: &quot;undefined&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;unknown&quot;,</span><br><span class="line">                &quot;plan_changed&quot;: false</span><br><span class="line">              &#125; /* index_order_summary */</span><br><span class="line">            &#125; /* reconsidering_access_paths_for_index_ordering */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* refine_plan */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_optimization */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;    -- 第三阶段：SQL执行阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;filesort_information&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;direction&quot;: &quot;asc&quot;,</span><br><span class="line">                &quot;table&quot;: &quot;`t_student`&quot;,</span><br><span class="line">                &quot;field&quot;: &quot;age&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* filesort_information */,</span><br><span class="line">            &quot;filesort_priority_queue_optimization&quot;: &#123;</span><br><span class="line">              &quot;usable&quot;: false,</span><br><span class="line">              &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot;</span><br><span class="line">            &#125; /* filesort_priority_queue_optimization */,</span><br><span class="line">            &quot;filesort_execution&quot;: [</span><br><span class="line">            ] /* filesort_execution */,</span><br><span class="line">            &quot;filesort_summary&quot;: &#123;</span><br><span class="line">              &quot;rows&quot;: 100000,</span><br><span class="line">              &quot;examined_rows&quot;: 100000,</span><br><span class="line">              &quot;number_of_tmp_files&quot;: 14,</span><br><span class="line">              &quot;sort_buffer_size&quot;: 262016,</span><br><span class="line">              &quot;sort_mode&quot;: &quot;&lt;sort_key, packed_additional_fields&gt;&quot;</span><br><span class="line">            &#125; /* filesort_summary */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_execution */</span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h1 id="八、SQL优化实战"><a href="#八、SQL优化实战" class="headerlink" title="八、SQL优化实战"></a>八、SQL优化实战</h1><h2 id="1-Order-by-优化"><a href="#1-Order-by-优化" class="headerlink" title="1.Order by 优化"></a>1.Order by 优化</h2><p>在Order by中，如果排序会造成文件排序（在磁盘中完成排序，这样的性能会比较差），那么就说明sql没有命中索引，怎么解决？可以使用最左前缀法则，让排序遵循最左前缀法则，避免文件排序。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN select * from student where name = &#x27;wangjie&#x27; order by age,phone;</span><br></pre></td></tr></table></figure></div>

<p>优化手段：</p>
<ul>
<li>如果排序的字段创建了联合索引，那么尽量在业务不冲突的情况下，遵循最左前缀法则来写排序语句</li>
<li>如果文件排序没办法避免，那么尽量想办法使用 <code>覆盖索引</code>（查询的列存在于联合索引中，避免回表查询）。 all -&gt; index</li>
</ul>
<h2 id="2-Group-by-优化"><a href="#2-Group-by-优化" class="headerlink" title="2.Group by 优化"></a>2.Group by 优化</h2><p>group by 的原理是先排序后分组，因此对于group by的优化参考 order by</p>
<h2 id="3-文件排序的原理"><a href="#3-文件排序的原理" class="headerlink" title="3.文件排序的原理"></a>3.文件排序的原理</h2><p>在执行文件排序的时候，会把查询的数据的大小与系统变量：max_length_for_sort_data的大小进行比较（默认是1024字节），如果比系统变量小，那么执行单路排序，反之则执行双路排序。</p>
<ul>
<li><p><span id="dlpx">单路排序</span></p>
<p>把所有的数据扔到sort_buffer内存缓冲区中，进行排序，然后结束</p>
</li>
<li><p><span id="slpx">双路排序</span></p>
<p>取数据的排序字段和主键字段，在内存缓冲区中排序完成后，将主键字段做一次回表查询，获取完整数据。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041017630.png"
                     
                ></p>
<h2 id="4-分页优化"><a href="#4-分页优化" class="headerlink" title="4.分页优化"></a>4.分页优化</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from student order by name limit 1000000,10</span><br><span class="line">-- 通过先进行覆盖索引的查找，然后再使用join做连接查询获取所有数据。这样比全表扫描要快</span><br><span class="line">explain select * from student a inner join (select id from student order by name limit 1000000,10) b on a.id = b.id;</span><br></pre></td></tr></table></figure></div>

<h2 id="5-join查询优化"><a href="#5-join查询优化" class="headerlink" title="5.join查询优化"></a>5.join查询优化</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from t1 inner join t2 on t1.a = t2.a</span><br><span class="line">-- t1 有1万行记录（大表）</span><br><span class="line">-- t2 只有100行记录（小表）</span><br><span class="line">-- 在join查询中，如果关联字段建立了索引，mysql就会使用 NLJ 算法，去找小表（数据量比较小的表）作为驱动表，先从驱动表中读一行数据，然后拿这一行数据去被驱动表（数据量比较大的表）中做查询。这样的大表和小表是由mysql内部优化器来决定的，跟sql语句中表的书写顺序无关。  —NLJ算法</span><br><span class="line">-- 如果没有索引，会创建一个join buffer内存缓冲区，把小表数据存起来（为什么不存大表，因为缓冲区大小限制，内存数据消耗性能的考虑），用内存缓冲区中的100行记录去和大表中的1万行记录进行比较，比较的过程依然是在内存中进行的。索引join buffer起到了提高join效率的效果。 ——BNLJ算法</span><br><span class="line">-- NLJ（nested loop join）：嵌套循环join</span><br><span class="line">-- BNLJ（block nested loop join）:块嵌套循环join</span><br></pre></td></tr></table></figure></div>

<ul>
<li>NLJ（嵌套循环算法）：如果关联字段使用了索引，mysql会对小表做全表扫描，用小表的数据去和大表的数据去做索引字段的关联查询。（type：ref)</li>
<li>BNLJ（块嵌套循环算法）：如果关联字段没有使用索引，mysql会提供一个join buffer缓冲区，先把小表放到缓冲区，然后全表扫描大表，把大表的数据和缓冲区中的小表数据在内存中进行匹配。</li>
</ul>
<p>结论：如果使用join查询，那么join的两个表的关联字段一定要创建索引，而且字段的长度类型一定要是一致的（这里在表设计的时候就需要考虑到），否则索引会失效，会使用BNLJ算法，全表扫描。</p>
<h2 id="6-in和exsits优化"><a href="#6-in和exsits优化" class="headerlink" title="6.in和exsits优化"></a>6.in和exsits优化</h2><p>在sql中，如果A表是大表，B表是小表，那么使用in会更加合适，反之使用exists。</p>
<ul>
<li><p>in：B的数据量 &lt; A的数据量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from A where id in (select id from B)</span><br><span class="line"># 相当于：</span><br><span class="line">for(select id from B)&#123; //B的数据量少，所以循环次数少。</span><br><span class="line">	select * from A where A.id = b.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>exists：B的数据量 &gt; A的数据量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from A where exists (select 1 from B where B.id = A.id)	true / false</span><br><span class="line"># 相当于</span><br><span class="line">for(select * from A)&#123;</span><br><span class="line">	select * from B where B.id = A.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="7-count优化"><a href="#7-count优化" class="headerlink" title="7.count优化"></a>7.count优化</h2><p>对于count的优化应该是架构层面的优化，因为count的统计是在一个产品会经常出现，而且每个用户都会访问，所以对于访问频率过高的数据建议维护在缓存中。</p>
<h1 id="九、锁的定义和分类"><a href="#九、锁的定义和分类" class="headerlink" title="九、锁的定义和分类"></a>九、锁的定义和分类</h1><h2 id="1-锁的定义"><a href="#1-锁的定义" class="headerlink" title="1.锁的定义"></a>1.锁的定义</h2><p>锁是用来解决多个任务（线程、进程）在并发访问同一共享资源时带来的数据安全问题。虽然使用锁解决了数据安全问题，但是会带来性能的影响，频繁使用锁的程序的性能是必然很差的。</p>
<p>对于数据库管理软件MySQL来说，必然会遇到任务的并发访问。那么MySQL是如何在数据安全和性能上做权衡的呢？—— MVCC设计思想。</p>
<h2 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2.锁的分类"></a>2.锁的分类</h2><h3 id="1）从性能上划分：乐观锁和悲观锁"><a href="#1）从性能上划分：乐观锁和悲观锁" class="headerlink" title="1）从性能上划分：乐观锁和悲观锁"></a>1）从性能上划分：乐观锁和悲观锁</h3><ul>
<li><p>悲观锁：悲观的认为当前的并发是非常严重的，所以在任何时候操作都是互斥的。保证了线程的安全，但牺牲了并发性。 ——总有刁民要害朕。</p>
</li>
<li><p>乐观锁：乐观的认为当前的并发并不严重，因此对于读的情况，大家都可以进行，但是对于写的情况，再进行上锁。以CAS自旋锁为例，在某种情况下性能是ok的，但是频繁自旋会消耗很大的资源。——天网恢恢疏而不漏</p>
</li>
</ul>
<h3 id="2）从数据的操作细粒度上划分：表锁和行锁"><a href="#2）从数据的操作细粒度上划分：表锁和行锁" class="headerlink" title="2）从数据的操作细粒度上划分：表锁和行锁"></a>2）从数据的操作细粒度上划分：表锁和行锁</h3><ul>
<li>表锁：对整张表上锁</li>
<li>行锁：对表中的某一行上锁</li>
</ul>
<h3 id="3）从数据库的操作类型上划分：读锁和写锁"><a href="#3）从数据库的操作类型上划分：读锁和写锁" class="headerlink" title="3）从数据库的操作类型上划分：读锁和写锁"></a>3）从数据库的操作类型上划分：读锁和写锁</h3><p>这两种锁都是属于悲观锁</p>
<ul>
<li>读锁（共享锁）：对于同一行数据进行“读”来说，是可以同时进行，但是不可以写。</li>
<li>写锁（排他锁）：在上了写锁之后，及释放写锁之前，在整个过程中是不能进行任何的其他并发操作（其他任务的读和写诗都不能进行的）。</li>
</ul>
<h2 id="3-表锁（实际开发中不要上表锁）"><a href="#3-表锁（实际开发中不要上表锁）" class="headerlink" title="3.表锁（实际开发中不要上表锁）"></a>3.表锁（实际开发中不要上表锁）</h2><p>对整张表进行上锁。MyISAM存储引擎是天然支持表锁的，也就是说在MyISAM的存储引擎的表中如果出现并发的情况，将会出现表锁的效果。MySAM不支持事务，InnoDB支持事务。</p>
<p>在InnoDB中上一下表锁</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 对一张表上读锁<span class="operator">/</span>写锁格式：</span><br><span class="line">lock <span class="keyword">table</span> 表名 read<span class="operator">/</span>write;</span><br><span class="line"># 例子</span><br><span class="line">lock <span class="keyword">table</span> tb_book read;</span><br><span class="line"># 查看当前会话对所有表的上锁情况</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line"># 释放当前会话的所有锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure></div>

<p>读锁：其他任务可以进行读，但是不能进行写</p>
<p>写锁：其他任务不能进行读和写。</p>
<h2 id="4-行锁"><a href="#4-行锁" class="headerlink" title="4.行锁"></a>4.行锁</h2><p>MyISAM只支持表锁，但不支持行锁，InnoDB可以支持行锁。</p>
<p>在并发事务里，每个事务的增删改的操作相当于是加了行锁。</p>
<p>上行锁的方式：</p>
<ul>
<li>update tb_book set name&#x3D;’java2010’ where id &#x3D; 8; 对id是8的这行数据上了行锁。</li>
<li>select * from tb_book where id &#x3D; 5 for update; 对id是5的这行数据上了行锁。</li>
</ul>
<h2 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h2><p>所谓死锁，就是开启的锁没办法关闭，导致资源的访问因为无法获得锁而处于阻塞状态。</p>
<p>演示：事务A和事务B相互持有对方需要的锁而不释放，造成死锁的情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041017395.png"
                     
                ></p>
<h2 id="6-间隙锁"><a href="#6-间隙锁" class="headerlink" title="6.间隙锁"></a>6.间隙锁</h2><p>行锁只能对某一行上锁，如果想对某一范围上锁，就可以使用间隙锁。间隙锁给的条件 where id&gt;13 and id&lt;19,会对13和19所处的间隙进行上锁（12 和 20 都会被锁住）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041018901.png"
                     
                ></p>
<h2 id="7-锁监控"><a href="#7-锁监控" class="headerlink" title="7.锁监控"></a>7.锁监控</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status \g</span><br></pre></td></tr></table></figure></div>

<h1 id="十、MVCC设计思想"><a href="#十、MVCC设计思想" class="headerlink" title="十、MVCC设计思想"></a>十、MVCC设计思想</h1><p><strong>MVCC</strong>全称是<strong>Multi-Version Concurrency Control</strong>（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。</p>
<p>如果没有<strong>MVCC</strong>，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。</p>
<p>有了<strong>MVCC</strong>，就相当于把同一份数据生成了多个版本，在操作的开始各生成一个快照，读写操作互不影响。无需加锁，也实现数据的安全性和事务的隔离性。</p>
<p>事务的四大特性中隔离性就是基于<strong>MVCC</strong>实现的。</p>
<p>说MVCC的实现原理之前，先说一下事务的隔离级别。</p>
<h2 id="1-事务的特性"><a href="#1-事务的特性" class="headerlink" title="1.事务的特性"></a>1.事务的特性</h2><ul>
<li>原子性：一个事务是一个最小的操作单位（原子），多条sql语句在一个事务中要么同时成功，要么同时失败。</li>
<li>一致性：事务提交之前和回滚之后的数据是一致的。</li>
<li>持久性：事务一旦提交，对数据的影响是持久的。</li>
<li>隔离性：多个事务在并发访问下，提供了一套隔离机制，不同的<span style="color:red"><strong>隔离级别</strong></span>会有不同的并发效果。</li>
</ul>
<h2 id="2-事务的隔离级别"><a href="#2-事务的隔离级别" class="headerlink" title="2.事务的隔离级别"></a>2.事务的隔离级别</h2><ul>
<li>读未提交（read uncommitted）：在一个事务中读取到另一个事务还没有提交的数据——脏读。</li>
<li>读已提交（read committed）：已经解决了脏读问题，在一个事务中只会读取另一个事务已提交的数据。这种情况会出现不可重复读的问题。在事务中重复读数据，数据的内容是不一样的。</li>
<li>可重复读（repeatable read）（MySQL默认）：在一个事务中每次读取的数据都是一致的，不会出现脏读和不可重复读的问题。会出现虚读的问题。</li>
<li>串行化（serializable）:串行化的隔离级别直接不允许事务的并发发生，不存在任何的并发性。相当于锁表，性能非常差，一般都不考虑。</li>
</ul>
<p>脏读、不可重复读、幻读</p>
<ul>
<li><p>脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
</li>
<li><p>不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间穿插了一个事务更新的原有的数据。</p>
</li>
<li><p>幻读：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041018376.png"
                     
                ></p>
<p>幻读解决方案：通过上行锁来解决幻读问题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041018303.png"
                     
                ></p>
</li>
</ul>
<h2 id="3-MVCC实现原理"><a href="#3-MVCC实现原理" class="headerlink" title="3.MVCC实现原理"></a>3.MVCC实现原理</h2><p>MySQL在读和写的操作中，对读的性能做了并发性的保障，让所有的读都是快照读，对于写的时候，进行版本控制，如果真实数据的版本比快照版本要新，那么写之前就要进行版本（快照）更新，这样就可以既能够提高读的并发性，又能够保证写的数据安全。</p>
<h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p><strong>当前读：</strong> 读取数据的最新版本，并对数据进行加锁。</p>
<p>例如：insert、update、delete、select for update、 select lock in share mode。</p>
<p><strong>快照读：</strong> 读取数据的历史版本，不对数据加锁。</p>
<p>例如：select</p>
<p>MVCC是基于Undo Log、隐藏字段、Read View（读视图）实现的。</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>先说一下MySQL的隐藏字段，当我们创建一张表时，InnoDB引擎会增加2个隐藏字段。</p>
<p><strong>DB_TRX_ID（最近一次提交事务的ID）</strong>：修改表数据时，都会提交事务，每个事务都有一个唯一的ID，这个字段就记录了最近一次提交事务的ID。</p>
<p><strong>DB_ROLL_PTR（上个版本的地址）</strong>：修改表数据时，旧版本的数据都会被记录到Undo Log日志中，每个版本的数据都有一个版本地址，这个字段记录的就是上个版本的地址。</p>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>当我们第一次往用户表插入一条记录时，表数据和隐藏字段的值是下面这样的：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name,age) <span class="keyword">values</span> (<span class="string">&#x27;一灯&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

<p>事务ID（DB_TRX_ID）是1，上个版本地址（DB_ROLL_PTR）是null。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041051688.png"
                     
                ></p>
<p>第二次提交事务，把用户年龄加1。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>事务ID变成2，上个版本地址指向Undo Log中的记录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041052746.png"
                     
                ></p>
<p>第三次提交事务，再把用户年龄加1。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>事务ID变成3，上个版本地址指向Undo Log中事务ID为2的记录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041053067.png"
                     
                ></p>
<p>这样表记录和<strong>Undo Log</strong>历史数据就组成了一个版本链。</p>
<h3 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read View（读视图）"></a>Read View（读视图）</h3><p>在事务中，执行SQL查询，就会生成一个读视图，是用来保证数据的可见性，即读到Undo Log中哪个版本的数据。</p>
<p><strong>快照读</strong>一般是读取的历史版本的读视图，<strong>当前图</strong>会生成一个最新版本的读视图。</p>
<p>读视图是基于下面几个字段实现的：</p>
<p><strong>m_ids</strong> ：当前系统中活跃的事务ID集合，即<strong>未提交的事务</strong>。</p>
<p><strong>min_trx_id</strong> ：m_ids中最小的ID</p>
<p><strong>max_trx_id</strong> ：下一个要分配的事务ID</p>
<p><strong>creator_trx_id</strong>: 当前事务ID</p>
<p>读视图决定当前事务能读到哪个版本的数据，从表记录到<strong>Undo Log</strong>历史数据的版本链，依次匹配，满足哪个版本的匹配规则，就能读到哪个版本的数据，一旦匹配成功就不再往下匹配。</p>
<p><strong>数据可见性规则：</strong></p>
<ol>
<li><strong>DB_TRX_ID &#x3D; creator_trx_id</strong><br>如果这个版本数据的事务ID等于当前事务ID，表示数据记录的最后一次操作的事务就是当前事务，当前读视图可以读到这个版本的数据。</li>
<li><strong>DB_TRX_ID &lt; min_trx_id</strong><br>如果这个版本数据的事务ID小于所有活跃事务ID，表示这个版本的数据不再被事务使用，即事务已提交，当前读视图可以读到这个版本的数据。</li>
<li><strong>DB_TRX_ID &gt;&#x3D; max_trx_id</strong><br>如果这个版本数据的事务ID大于等于下一个要分配的事务ID，表示有新事务更新了这个版本的数据，这种情况下，当前读视图不可以读到这个版本的数据。</li>
<li><strong>min_trx_id &lt;&#x3D; DB_TRX_ID &lt; max_trx_id</strong><br>如果这个版本数据的事务ID在当前系统中活跃的事务ID集合（m_ids）里面，表示这个版本的数据被其他事务更新过，当前读视图不可以读到这个版本的数据。<br>如果这个版本数据的事务ID不在当前系统中活跃的事务ID集合（m_ids）里面（代表事务已经提交了），且这个版本数据的事务ID小于最大的事务ID，表示此次是在其他事务提交后创建的读视图，当前读视图可以读到这个版本的数据。</li>
</ol>
<h3 id="不同隔离级别下可见性分析"><a href="#不同隔离级别下可见性分析" class="headerlink" title="不同隔离级别下可见性分析"></a>不同隔离级别下可见性分析</h3><p>在不同的事务隔离级别下，生成读视图的规则不同：</p>
<ul>
<li><strong>READ COMMITTED（读已提交）</strong> ：在事务中每一次执行快照读时都生成一个读视图，每个读视图中四个字段的值都是不同的。</li>
<li><strong>REPEATABLE READ（可重复读）</strong>：仅在事务中第一次执行快照读时生成读视图，后续复用这个读视图。</li>
</ul>
<h1 id="十一、MySQL三大日志"><a href="#十一、MySQL三大日志" class="headerlink" title="十一、MySQL三大日志"></a>十一、MySQL三大日志</h1><p>日志是 <code>mysql</code> 数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志( <code>binlog</code> )和事务日志(包括<code>redo log</code> 和 <code>undo log</code> )，本文接下来会详细介绍这三种日志。</p>
<h2 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1.binlog"></a>1.binlog</h2><p><code>binlog</code> 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code> 是 <code>mysql</code>的逻辑日志，并且由 <code>Server</code> 层进行记录，使用任何存储引擎的 <code>mysql</code> 数据库都会记录 <code>binlog</code> 日志。</p>
<ul>
<li><strong>逻辑日志</strong>：可以简单理解为记录的就是sql语句 。</li>
<li><strong>物理日志</strong>：<code>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<p><code>binlog</code> 是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code> 参数设置每个 <code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<h3 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a><strong>binlog使用场景</strong></h3><p>在实际应用中， <code>binlog</code> 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p>
<ol>
<li><strong>主从复制</strong> ：在 <code>Master</code> 端开启 <code>binlog</code> ，然后将 <code>binlog</code>发送到各个 <code>Slave</code> 端， <code>Slave</code> 端重放 <code>binlog</code> 从而达到主从数据一致。</li>
<li><strong>数据恢复</strong> ：通过使用 <code>mysqlbinlog</code> 工具来恢复数据。</li>
</ol>
<h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a><strong>binlog刷盘时机</strong></h3><p>对于 <code>InnoDB</code> 存储引擎而言，只有在事务提交时才会记录<code>biglog</code> ，此时记录还在内存中，那么 <code>biglog</code>是什么时候刷到磁盘中的呢？<code>mysql</code> 通过 <code>sync_binlog</code> 参数控制 <code>biglog</code> 的刷盘时机，取值范围是 <code>0-N</code>：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次 <code>commit</code> 的时候都要将 <code>binlog</code> 写入磁盘；</li>
<li>N：每N个事务，才会将 <code>binlog</code> 写入磁盘。</li>
</ul>
<p>从上面可以看出， <code>sync_binlog</code> 最安全的是设置是 <code>1</code> ，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h3 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a><strong>binlog日志格式</strong></h3><p><code>binlog</code> 日志有三种格式，分别为 <code>STATMENT</code> 、 <code>ROW</code> 和 <code>MIXED</code>。</p>
<blockquote>
<p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code> ， <code>MySQL 5.7.7</code> 之后，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p>
</blockquote>
<ul>
<li>STATMENT：基于<code>SQL</code> 语句的复制( <code>statement-based replication, SBR</code> )，每一条会修改数据的sql语句会记录到<code>binlog</code> 中 。<ul>
<li>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO , 从而提高了性能；</li>
<li>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、 slepp() 等 。</li>
</ul>
</li>
<li>ROW：基于行的复制(<code>row-based replication, RBR</code> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。<ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；</li>
<li>缺点：会产生大量的日志，尤其是<code>alter table</code> 的时候会让日志暴涨</li>
</ul>
</li>
<li>MIXED：基于<code>STATMENT</code> 和 <code>ROW</code> 两种模式的混合复制(<code>mixed-based replication, MBR</code> )，一般的复制使用<code>STATEMENT</code> 模式保存 <code>binlog</code> ，对于 <code>STATEMENT</code> 模式无法复制的操作使用 <code>ROW</code> 模式保存 <code>binlog</code></li>
</ul>
<h2 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2.redo log"></a>2.redo log</h2><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h3><p>我们都知道，事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。</p>
<p>那么 <code>mysql</code>是如何保证一致性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p>
<ol>
<li>因为 <code>Innodb</code> 是以 <code>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li>
</ol>
<p>因此 <code>mysql</code> 设计了 <code>redo log</code> ， <strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p>
<h3 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a>redo log基本概念</h3><p>redo log 包括两部分：一个是内存中的日志缓冲( <code>redo log buffer</code> )，另一个是磁盘上的日志文件( <code>redo logfile</code>)。<code>mysql</code> 每执行一条 <code>DML</code> 语句，先将记录写入 <code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到 <code>redo log file</code>。这种 <strong>先写日志，再写磁盘</strong> 的技术就是 MySQL里经常说到的 <code>WAL(Write-Ahead Logging)</code> 技术。在计算机操作系统中，用户空间( <code>user space</code> )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( <code>kernel space</code> )缓冲区( <code>OS Buffer</code> )。因此， <code>redo log buffer</code> 写入 <code>redo logfile</code> 实际上是先写入 <code>OS Buffer</code> ，然后再通过系统调用 <code>fsync()</code> 将其刷到 <code>redo log file</code>中，过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041019752.png"
                     
                ></p>
<p><code>mysql</code> 支持三种将 <code>redo log buffer</code> 写入 <code>redo log file</code> 的时机，可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数配置，各参数值含义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041019061.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041020813.png"
                     
                ></p>
<h3 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a>redo log记录形式</h3><p>前面说过， <code>redo log</code> 实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 <code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041020541.png"
                     
                ></p>
<p>同时我们很容易得知， 在innodb中，既有<code>redo log</code> 需要刷盘，还有 <code>数据页</code> 也需要刷盘， <code>redo log</code>存在的意义主要就是降低对 <code>数据页</code> 刷盘的要求  。在上图中， <code>write pos</code> 表示 <code>redo log</code> 当前记录的 <code>LSN</code> (逻辑序列号)位置， <code>check point</code> 表示 <strong>数据页更改记录</strong> 刷盘后对应 <code>redo log</code> 所处的 <code>LSN</code>(逻辑序列号)位置。<code>write pos</code> 到 <code>check point</code> 之间的部分是 <code>redo log</code> 空着的部分，用于记录新的记录；<code>check point</code> 到 <code>write pos</code> 之间是 <code>redo log</code> 待落盘的数据页更改记录。当 <code>write pos</code>追上<code>check point</code> 时，会先推动 <code>check point</code> 向前移动，空出位置再记录新的日志。启动 <code>innodb</code> 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 <code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 <code>binlog</code> )要快很多。重启<code>innodb</code> 时，首先会检查磁盘中数据页的 <code>LSN</code> ，如果数据页的<code>LSN</code> 小于日志中的 <code>LSN</code> ，则会从 <code>checkpoint</code> 开始恢复。还有一种情况，在宕机前正处于<code>checkpoint</code> 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 <code>LSN</code> 大于日志中的 <code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p>
<h3 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411041020153.png"
                     
                ></p>
<p>由 <code>binlog</code> 和 <code>redo log</code> 的区别可知：<code>binlog</code> 日志只用于归档，只依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的。但只有 <code>redo log</code> 也不行，因为 <code>redo log</code> 是 <code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code>binlog</code>和 <code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p>
<h2 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3.undo log"></a>3.undo log</h2><p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。实际上， <strong>原子性</strong> 底层就是通过 <code>undo log</code> 实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条 <code>INSERT</code> 语句，对应一条<code>DELETE</code> 的 <code>undo log</code> ，对于每个 <code>UPDATE</code> 语句，对应一条相反的 <code>UPDATE</code> 的 <code>undo log</code> ，这样在发生错误时，就能回滚到事务之前的数据状态。同时， <code>undo log</code> 也是 <code>MVCC</code>(多版本并发控制)实现的关键。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建个人博客</title>
    <url>/2024/11/03/%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h4><p>首先安装 Node.js、npm、git工具。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; node -v</span><br><span class="line">v12.22.9</span><br><span class="line">&gt; npm -v</span><br><span class="line">8.5.1</span><br><span class="line">&gt; git version</span><br><span class="line">git version 2.34.1</span><br></pre></td></tr></table></figure></div>

<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">&gt; hexo -v</span><br><span class="line">hexo-cli: 4.3.2</span><br><span class="line">os: darwin 22.6.0 13.6.7</span><br><span class="line"></span><br><span class="line">node: 20.8.1</span><br><span class="line">acorn: 8.10.0</span><br><span class="line">ada: 2.6.0</span><br><span class="line">ares: 1.19.1</span><br><span class="line"><span class="built_in">base64</span>: 0.5.0</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">cjs_module_lexer: 1.2.2</span><br><span class="line">cldr: 43.1</span><br><span class="line">icu: 73.2</span><br><span class="line">llhttp: 8.1.1</span><br><span class="line">modules: 115</span><br><span class="line">napi: 9</span><br><span class="line">nghttp2: 1.57.0</span><br><span class="line">nghttp3: 0.7.0</span><br><span class="line">ngtcp2: 0.8.1</span><br><span class="line">openssl: 3.0.10+quic</span><br><span class="line">simdutf: 3.2.17</span><br><span class="line">tz: 2023c</span><br><span class="line">undici: 5.26.3</span><br><span class="line">unicode: 15.0</span><br><span class="line">uv: 1.46.0</span><br><span class="line">uvwasi: 0.0.18</span><br><span class="line">v8: 11.3.244.8-node.16</span><br><span class="line">zlib: 1.2.13.1-motley</span><br></pre></td></tr></table></figure></div>

<h4 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h4><p>首先创建博客的根目录文件夹</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">mkdir</span> MyBlob</span><br><span class="line">&gt; <span class="built_in">cd</span> MyBlob</span><br></pre></td></tr></table></figure></div>

<p>之后，就可以初始化这个文件夹了，初始化的目的是，它会创建一个 helloword.md 文件，然后利用 node.js 等将这个 markdown 文件渲染成一个 html 文件，然后在本地开启一个网络服务器以供前端访问</p>
<p>由于网络问题（npm 的服务器位于国外下载慢）可以使用 cnpm（淘宝团队做的国内镜像）的获取镜像或者直接修改 npm 的资源获取地址为国内的。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装cnmp</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接修改npm资源获取地址（推荐）</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo init</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure></div>

<p>成功初始化后，会在当前文件夹下生成一些文件，目录结构如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411032253551.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── _config.landscape.yml：主题配置文件，如果</span><br><span class="line"></span><br><span class="line">├── _config.yml：站点配置文件，对站点进行配置。</span><br><span class="line"></span><br><span class="line">├── node_modules：用来存储已安装的各类依赖包。</span><br><span class="line"></span><br><span class="line">├── package-lock.json：包版本依赖锁文件。</span><br><span class="line"></span><br><span class="line">├── package.json：应用数据，Hexo的版本以及相关依赖包的版本等。</span><br><span class="line"></span><br><span class="line">├── scaffolds：博客模版文件夹，包含page.md，post.md，draft.md三种。</span><br><span class="line"></span><br><span class="line">├── source：资源文件夹，存放静态资源如博客md文件、图片等。</span><br><span class="line"></span><br><span class="line">└── themes：主题文件夹，Hexo通过将网站内容与主题组合来生成静态网站。</span><br></pre></td></tr></table></figure></div>

<p>初始化项目后，我们只需在根目录下本地执行下面命令即可在本地进行预览</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></div>

<p>然后我们访问<code>http://localhost:4000/</code>即可查看网站啦</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411032257329.png"
                     
                ></p>
<h4 id="Hexo基本命令介绍"><a href="#Hexo基本命令介绍" class="headerlink" title="Hexo基本命令介绍"></a>Hexo基本命令介绍</h4><ul>
<li><p><strong>本地启动项目，s 表示 server</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo s</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411032301146.png"
                     
                ></p>
</li>
<li><p><strong>创建一个新的文章</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo new [layout] &lt;title&gt;</span><br><span class="line">如：hexo new <span class="string">&quot;我的第一篇博客 Hexo Hello!&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>layout 表示文章布局，可选（post page draft），默认使用 <code>_config.yml</code>中的 default_layout 参数代替（post）。</p>
<p>title 表示文章标题，如果标题包含空格的话，请使用引号括起来。</p>
</li>
<li><p><strong>Front-matter</strong></p>
<p><a class="link"   href="https://hexo.io/zh-cn/docs/front-matter" >参看官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Sports</span><br><span class="line">  - Baseball</span><br><span class="line">tags:</span><br><span class="line">  - Injury</span><br><span class="line">  - Fight</span><br><span class="line">  - Shocking</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>生成静态文件，g 表示 generate</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo g</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411032304909.png"
                     
                ></p>
</li>
<li><p><strong>部署Hexo网站，d 表示 deploy</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo d</span><br></pre></td></tr></table></figure></div>

<p>更多相关指令可以前往官网查看：<a class="link"   href="https://hexo.io/zh-cn/docs/commands" >https://hexo.io/zh-cn/docs/commands <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h4 id="Hexo基本配置修改"><a href="#Hexo基本配置修改" class="headerlink" title="Hexo基本配置修改"></a>Hexo基本配置修改</h4><p><strong>【必改部分】</strong> 站点的基本设置，首页标题、子标题、简介、关键词（英文,隔开）、作者、语言和时区，都需要修改，这样才算自己的网站嘛。</p>
<p>打开<code>_config.yml</code>，修改以下部分</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Wangjie&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;知识总结&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;Hexo+Github&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">java</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Wangjie</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>重启下 Hexo 服务，我们刷新页面，就会发现上面的修改生效啦～如果没有生效，你可以先运行下<code>hexo clean</code>先清除缓存，然后再执行<code>hexo s</code>启动服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411032350227.png"
                     
                ></p>
<p><strong>【选改部分】</strong> </p>
<p>访问路径相关设置</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure></div>

<p>原主题太简陋了，我从官网主题地址：<a class="link"   href="https://hexo.io/themes/" >https://hexo.io/themes/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中下载了<code>Redefine</code>主题，所以我们需要将配置中的主题改为<code>redefine</code>，大家也可以选择其他主题。</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Redefine主题使用文档"><a href="#Redefine主题使用文档" class="headerlink" title="Redefine主题使用文档"></a><a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >Redefine主题使用文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><blockquote>
<p>[!NOTE]</p>
<p>注意，该主题Hexo 版本需要大于 5.0.0</p>
<p><strong>Hexo版本升级</strong></p>
<p>Hexo版本升级可以通过npm实现，相关命令如下：<br>先全局升级<code>hexo-cli</code>：-g表示全局升级。<code>hexo</code>本身是一个静态博客生成工具，具备编译Markdown、拼接主题模板、生成 HTML、上传 Git 等基本功能。<code>hexo-cli</code>能够将这些功能封装为命令，提供给用户通过<code>hexo server / hexo deploy</code>等命令调用的模块。<code>CLI = Command Line Interface</code>命令行界面。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm i hexo-cli -g</span><br></pre></td></tr></table></figure></div>

<p>然后直接输入：(其实这个命令应该不正确)，输入之后发现出现了一系列的warn。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm update</span><br></pre></td></tr></table></figure></div>

<p>再输入<code>hexo vesion</code>查看当前版本，发现版本已经更新成功了。</p>
</blockquote>
<h4 id="将-Hexo-博客部署到-GitHub"><a href="#将-Hexo-博客部署到-GitHub" class="headerlink" title="将 Hexo 博客部署到 GitHub"></a>将 Hexo 博客部署到 GitHub</h4><p>首先我们先需要新建在 GitHub 上新建一个项目：<a class="link"   href="https://github.com/new" >https://github.com/new <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，项目名称格式需要注意，必须是<code>用户名.github.io</code>，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040157011.png"
                     
                ></p>
<p>同时我们需要配置下 SSH 密钥，具体配置方法可以查看我的历史文章：<a href="https://wj0410.github.io/2024/11/08/Git%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5%E5%88%86%E5%88%AB%E8%BF%9E%E6%8E%A5gitee%E5%92%8Cgithub/">Git设置多账号生成SSH公钥分别连接gitee和github</a></p>
<p>接着我们要修改下配置文件<code>_config.yml</code>，下滑到最后，将部署信息改为：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">	<span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">	<span class="attr">repo:</span> <span class="string">git@github.com:你的用户名/你的用户名.github.io.git</span>  </span><br><span class="line">	<span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040200907.png"
                     
                ></p>
<p>部署到 GitHub，需要安装相关工具 hexo-deployer-git。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div>

<p>接下来直接输入指令配置就行了，<code>hexo clean</code>清除缓存数据，<code>hexo g</code>生成相关静态文件。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean</span><br><span class="line">&gt; hexo g</span><br></pre></td></tr></table></figure></div>

<p>如果继续输入<code>hexo d</code>进行部署的时候，可能会报错，<code>Deployer not found: git</code> ，这个时候不要慌，这是因为在本地 Hexo 项目目录还没有初始化 git 造成的，我们运行下面命令进行初始化即可。如果没有报错则忽视。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; git init</span><br></pre></td></tr></table></figure></div>

<p>我们再次输入<code>hexo d</code>进行部署即可，可能会要求输入 GitHub 账号和密码（配置了 ssh 公钥就不需要了，上面有说如何配置），直接输入即可，上传完成后，再刷新 GitHub 页面会发现多了一些文件，原来的 readme 也不见了，这是因为 Hexo 每次部署都会将<code>hexo g</code>生成的静态文件（在 blog&#x2F;public 目录下）上传到 GitHub，<strong>并覆盖原先所有的内容</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040209477.png"
                     
                ></p>
<p>这个时候，我们在浏览器内访问</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://&lt;你的用户名&gt;.github.io/</span><br><span class="line"># 如：https://wj0410.github.io/</span><br></pre></td></tr></table></figure></div>

<p>即可访问我们的博客首页啦，点击博客也可以进入对应的博客页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040212042.png"
                     
                ></p>
<p>通过上面，我们已经得到了一个在线的、可以随时随地访问的个人博客，整个操作过程还是很简单的，麻烦的就是上传更新文章和部署项目了，每次部署都需要输入账号密码，另外由于 GitHub 服务器在国外，国内访问速度也很堪忧，不用担心，这个解决还比较简单，我们可以同时将项目部署到国内码云：<a class="link"   href="https://gitee.com/" >https://gitee.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>或者 Coding：<a class="link"   href="https://coding.net/" >https://coding.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，整个过程和将项目部署到 GitHub 差不多。</p>
<h4 id="设置应用自己的域名"><a href="#设置应用自己的域名" class="headerlink" title="设置应用自己的域名"></a>设置应用自己的域名</h4><p>如果你有域名的话，还可以设置专属域名，比如我之前在<a class="link"   href="https://www.aliyun.com/minisite/goods?taskPkg=1111ydsrwb&pkgSid=588&recordId=952736&userCode=g49jjzzx" >阿里云买的域名点击查看 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，当然大家也可以买<a class="link"   href="https://cloud.tencent.com/act" >腾讯云的点击查看 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，国内比较靠谱的两个云服务器和域名服务公司了～</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040215023.png"
                     
                ></p>
<p>首先我们需要在阿里云域名管理后台，进行域名解析，我们直接从我们自己的域名解析到博客的 github 地址，谈及一条 CNAME 记录即可，主机记录就是我们后面通过什么链接访问，记录值就是 github 访问地址了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040216584.png"
                     
                ></p>
<p>然后我们需要到 GitHub 对应项目中设置项目的域名，进入项目-&gt; Settings -&gt; Pages -&gt; <code>Custom domain</code>，将我们设置的 CNAME 域名写入即可（注意是在这个项目的设置里，并非 GitHub 的设置）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040218672.png"
                     
                ></p>
<p>最后我们还需要在本地项目中的 blog&#x2F;source 文件夹下新建一个<code>CNAME</code>文件，编辑写入我们的域名，就是刚刚填入 GitHub 的，这样后面 GitHub 就能映射到我们的域名啦。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/wj0410/pic-bed/master/202411040219142.png"
                     
                ></p>
<p>再执行下面命令，重新更新和部署项目</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hexo g</span><br><span class="line">&gt; hexo d</span><br></pre></td></tr></table></figure></div>

<p>部署成功后，我们直接访问<code>https://blog.python-brief.com/</code>（我自定义的域名）来查看我们的博客啦～</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a class="link"   href="https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f" >https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/m0_73651896/article/details/140237281" >https://blog.csdn.net/m0_73651896/article/details/140237281 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<hr>
<h4 id="问题补充"><a href="#问题补充" class="headerlink" title="问题补充"></a>问题补充</h4><h5 id="接入Gitalk时遇到跨域问题"><a href="#接入Gitalk时遇到跨域问题" class="headerlink" title="接入Gitalk时遇到跨域问题"></a>接入Gitalk时遇到跨域问题</h5><p>以前官方提供的demo代理 <a class="link"   href="https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token" >https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 也因为滥用停用了，解决办法有一些，但是前提得有一台服务器，得自己搭建一个代理来访问，例如使用<code>cors-anywhere</code>、<code>nginx</code>代理服务器等，这样就对静态博客的部署方式不太适用了。最后在<a class="link"   href="https://github.com/gitalk/gitalk/issues" >gitalk的issues中找到了能公开访问的代理地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这里就不贴出来了，因为我要自己偷偷用😊</p>
<p><a class="link"   href="https://blog.csdn.net/aoxiangchina/article/details/143814625" >代理搭建参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
